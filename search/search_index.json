{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs \u00b6 For full documentation visit mkdocs.org . Commands \u00b6 mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout \u00b6 mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"package_pyalgotrading/","text":"\u00b6 Official Python Package for Algorithmic Trading APIs powered by AlgoBulls. Links: GitHub | AlgoBulls algobulls special \u00b6 Package for interacting with the AlgoBulls backend api \u00b6 Module for handling API calls to the AlgoBulls backend. AlgoBullsAPI \u00b6 AlgoBulls API __init__ ( self ) special \u00b6 Init method that is used while creating an object of this class Source code in pyalgotrading/algobulls/api.py 20 21 22 23 24 def __init__ ( self ): \"\"\" Init method that is used while creating an object of this class \"\"\" self . headers = None create_strategy ( self , strategy_name , strategy_details , abc_version ) \u00b6 Create a new strategy for the user on the AlgoBulls platform. Parameters: Name Type Description Default strategy_name str name of the strategy required strategy_details str Python code of the strategy required abc_version str value of one of the enums available under AlgoBullsEngineVersion required Returns: Type Description dict JSON Response received from AlgoBulls platform after (attempt to) creating a new strategy. Warning For every user, the strategy_name should be unique. You cannot create multiple strategies with the same name. ENDPOINT POST v2/user/strategy/build/python Source code in pyalgotrading/algobulls/api.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def create_strategy ( self , strategy_name : str , strategy_details : str , abc_version : str ) -> dict : \"\"\" Create a new strategy for the user on the AlgoBulls platform. Args: strategy_name: name of the strategy strategy_details: Python code of the strategy abc_version: value of one of the enums available under [AlgoBullsEngineVersion]() Returns: JSON Response received from AlgoBulls platform after (attempt to) creating a new strategy. Warning: For every user, the `strategy_name` should be unique. You cannot create multiple strategies with the same name. Info: ENDPOINT `POST` v2/user/strategy/build/python \"\"\" json_data = { 'strategyName' : strategy_name , 'strategyDetails' : strategy_details , 'abcVersion' : abc_version } endpoint = f 'v2/user/strategy/build/python' response = self . _send_request ( endpoint = endpoint , method = 'post' , json_data = json_data ) return response get_all_strategies ( self ) \u00b6 Get all the Python strategies created by the user on the AlgoBulls platform Returns: Type Description dict JSON Response received from AlgoBulls platform with list of all the created strategies. ENDPOINT OPTIONS v2/user/strategy/build/python Source code in pyalgotrading/algobulls/api.py 119 120 121 122 123 124 125 126 127 128 129 130 131 def get_all_strategies ( self ) -> dict : \"\"\" Get all the Python strategies created by the user on the AlgoBulls platform Returns: JSON Response received from AlgoBulls platform with list of all the created strategies. Info: ENDPOINT `OPTIONS` v2/user/strategy/build/python \"\"\" endpoint = f 'v2/user/strategy/build/python' response = self . _send_request ( endpoint = endpoint , method = 'options' ) return response get_job_status ( self , strategy_code , trading_type , broker = '' ) \u00b6 Get status for a BACKTESTING/PAPERTESTING/REALTRADING Job Parameters: Name Type Description Default strategy_code str Strategy code required trading_type str Trading type required broker str Name of the broker '' Returns: Type Description dict Job status ENDPOINT GET v1/customer_strategy_algotrading Source code in pyalgotrading/algobulls/api.py 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 def get_job_status ( self , strategy_code : str , trading_type : str , broker : str = '' ) -> dict : \"\"\" Get status for a BACKTESTING/PAPERTESTING/REALTRADING Job Args: strategy_code: Strategy code trading_type: Trading type broker: Name of the broker Returns: Job status Info: ENDPOINT `GET` v1/customer_strategy_algotrading \"\"\" params = { 'strategyCode' : strategy_code , 'strategyType' : StrategyType . PYTHON . value , 'tradingType' : trading_type . value , 'broker' : broker } endpoint = f 'v1/customer_strategy_algotrading' response = self . _send_request ( endpoint = endpoint , params = params ) return response get_reports ( self , strategy_code , trading_type , report_type , broker = '' ) \u00b6 Get reports for a BACKTESTING/PAPERTESTING/REALTRADING Job Parameters: Name Type Description Default strategy_code str Strategy code required trading_type str Value of TradingType Enum required report_type str Value of TradingReportType Enum required broker str Name of the broker '' Returns: Type Description dict Report data ENDPOINT GET v1/customer_strategy_algotrading_reports Source code in pyalgotrading/algobulls/api.py 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 def get_reports ( self , strategy_code : str , trading_type : str , report_type : str , broker : str = '' ) -> dict : \"\"\" Get reports for a BACKTESTING/PAPERTESTING/REALTRADING Job Args: strategy_code: Strategy code trading_type: Value of TradingType Enum report_type: Value of TradingReportType Enum broker: Name of the broker Returns: Report data Info: ENDPOINT `GET` v1/customer_strategy_algotrading_reports \"\"\" params = { 'strategyCode' : strategy_code , 'strategyType' : StrategyType . PYTHON . value , 'tradingType' : trading_type . value , 'reportType' : report_type . value , 'broker' : broker } endpoint = f 'v1/customer_strategy_algotrading_reports' response = self . _send_request ( endpoint = endpoint , params = params ) return response get_strategy_details ( self , strategy_code ) \u00b6 Get strategy details for Parameters: Name Type Description Default strategy_code str unique code of strategy, which is received while creating the strategy or required Returns: Type Description dict JSON ENDPOINT GET v2/user/strategy/build/python Source code in pyalgotrading/algobulls/api.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 def get_strategy_details ( self , strategy_code : str ) -> dict : \"\"\" Get strategy details for Arguments: strategy_code: unique code of strategy, which is received while creating the strategy or Return: JSON Info: ENDPOINT `GET` v2/user/strategy/build/python \"\"\" params = { 'strategyCode' : strategy_code } endpoint = f 'v2/user/strategy/build/python' response = self . _send_request ( endpoint = endpoint , params = params ) return response search_instrument ( self , instrument ) \u00b6 Parameters: Name Type Description Default instrument str instrument key required Returns: Type Description dict JSON Response ENDPOINT GET v2/instrument/search Source code in pyalgotrading/algobulls/api.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 def search_instrument ( self , instrument : str ) -> dict : \"\"\" Args: instrument: instrument key Returns: JSON Response Info: ENDPOINT `GET` v2/instrument/search \"\"\" params = { 'instrument' : instrument } endpoint = f 'v2/instrument/search' response = self . _send_request ( endpoint = endpoint , params = params , requires_authorization = False ) return response set_access_token ( self , access_token ) \u00b6 Sets access token to the header attribute, which is needed for APIs requiring authorization Package for interacting with AlgoBulls Algorithmic Trading Platform (https://www.algobulls.com) Parameters: Name Type Description Default access_token str Access token generated by logging to the URL given by the get_authorization_url() method required Source code in pyalgotrading/algobulls/api.py 26 27 28 29 30 31 32 33 34 35 36 def set_access_token ( self , access_token : str ): \"\"\" Sets access token to the header attribute, which is needed for APIs requiring authorization Package for interacting with AlgoBulls Algorithmic Trading Platform (https://www.algobulls.com) Args: access_token: Access token generated by logging to the URL given by the `get_authorization_url()` method \"\"\" self . headers = { 'Authorization' : f ' { access_token } ' } set_strategy_config ( self , strategy_code , strategy_config ) \u00b6 Parameters: Name Type Description Default strategy_code str strategy code required strategy_config str strategy configuration required Returns: Type Description dict Info: ENDPOINT PATCH v1/customer_strategy_tweak Source code in pyalgotrading/algobulls/api.py 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 def set_strategy_config ( self , strategy_code : str , strategy_config : str ) -> dict : \"\"\" Args: strategy_code: strategy code strategy_config: strategy configuration Returns: Info: ENDPOINT PATCH v1/customer_strategy_tweak \"\"\" params = { 'strategyCode' : strategy_code , 'strategyType' : StrategyType . PYTHON . value } json_data = strategy_config endpoint = f 'v1/customer_strategy_tweak' response = self . _send_request ( method = 'patch' , endpoint = endpoint , params = params , json_data = json_data ) return response start_strategy_algotrading ( self , strategy_code , trading_type , broker = '' ) \u00b6 Submit Backtesting / Paper Trading / Real Trading job for strategy with code strategy_code & return the job ID. ENDPOINT POST v1/customer_strategy_algotrading Source code in pyalgotrading/algobulls/api.py 187 188 189 190 191 192 193 194 195 196 197 198 def start_strategy_algotrading ( self , strategy_code : str , trading_type : str , broker : str = '' ) -> dict : \"\"\" Submit Backtesting / Paper Trading / Real Trading job for strategy with code strategy_code & return the job ID. Info: ENDPOINT `POST` v1/customer_strategy_algotrading \"\"\" params = { 'strategyCode' : strategy_code , 'strategyType' : StrategyType . PYTHON . value , 'tradingType' : trading_type . value , 'broker' : broker } endpoint = f 'v1/customer_strategy_algotrading' json_data = { 'action' : 'start' } response = self . _send_request ( method = 'post' , endpoint = endpoint , params = params , json_data = json_data ) return response stop_strategy_algotrading ( self , strategy_code , trading_type , broker = '' ) \u00b6 Stop Backtesting / Paper Trading / Real Trading job for strategy with code strategy_code & return the job ID. ENDPOINT POST v1/customer_strategy_algotrading Source code in pyalgotrading/algobulls/api.py 200 201 202 203 204 205 206 207 208 209 210 211 def stop_strategy_algotrading ( self , strategy_code : str , trading_type : str , broker : str = '' ) -> dict : \"\"\" Stop Backtesting / Paper Trading / Real Trading job for strategy with code strategy_code & return the job ID. Info: ENDPOINT `POST` v1/customer_strategy_algotrading \"\"\" params = { 'strategyCode' : strategy_code , 'strategyType' : StrategyType . PYTHON . value , 'tradingType' : trading_type . value , 'broker' : broker } endpoint = f 'v1/customer_strategy_algotrading' json_data = { 'action' : 'stop' } response = self . _send_request ( method = 'post' , endpoint = endpoint , params = params , json_data = json_data ) return response update_strategy ( self , strategy_name , strategy_details , abc_version ) \u00b6 Update an already existing strategy on the AlgoBulls platform Parameters: Name Type Description Default strategy_name str name of the strategy required strategy_details str Python code of the strategy required abc_version str value of one of the enums available under AlgoBullsEngineVersion required Returns: Type Description dict JSON Response received from AlgoBulls platform after (attempt to) updating an existing strategy. ENDPOINT PUT v2/user/strategy/build/python Source code in pyalgotrading/algobulls/api.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 def update_strategy ( self , strategy_name : str , strategy_details : str , abc_version : str ) -> dict : \"\"\" Update an already existing strategy on the AlgoBulls platform Args: strategy_name: name of the strategy strategy_details: Python code of the strategy abc_version: value of one of the enums available under `AlgoBullsEngineVersion` Returns: JSON Response received from AlgoBulls platform after (attempt to) updating an existing strategy. Info: ENDPOINT PUT v2/user/strategy/build/python \"\"\" json_data = { 'strategyName' : strategy_name , 'strategyDetails' : strategy_details , 'abcVersion' : abc_version } endpoint = f 'v2/user/strategy/build/python' response = self . _send_request ( endpoint = endpoint , method = 'put' , json_data = json_data ) return response connection \u00b6 Module for AlgoBulls connection AlgoBullsConnection \u00b6 Class for Algobulls connection __init__ ( self ) special \u00b6 Init method that is used while creating an object of this class Source code in pyalgotrading/algobulls/connection.py 20 21 22 23 24 def __init__ ( self ): \"\"\" Init method that is used while creating an object of this class \"\"\" self . api = AlgoBullsAPI () backtest ( self , strategy_code , start_timestamp , end_timestamp , instrument_id , strategy_parameters , candle_interval , strategy_mode =< StrategyMode . INTRADAY : 0 > ) \u00b6 Parameters: Name Type Description Default strategy_code strategy code required start_timestamp start date/time required end_timestamp end date/time required instrument_id instrument key required strategy_parameters parameters required candle_interval candle interval required strategy_mode intraday or delivery <StrategyMode.INTRADAY: 0> Returns: Type Description backtest status Source code in pyalgotrading/algobulls/connection.py 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 def backtest ( self , strategy_code , start_timestamp , end_timestamp , instrument_id , strategy_parameters , candle_interval , strategy_mode = StrategyMode . INTRADAY ): \"\"\" Args: strategy_code: strategy code start_timestamp: start date/time end_timestamp: end date/time instrument_id: instrument key strategy_parameters: parameters candle_interval: candle interval strategy_mode: intraday or delivery Returns: backtest status \"\"\" # Sanity checks - Validate config parameters assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' assert ( isinstance ( start_timestamp , dt ) is True ), f 'Argument start_timestamp should be an instance of type datetime.datetime' assert ( isinstance ( end_timestamp , dt ) is True ), f 'Argument start_timestamp should be an instance of type datetime.datetime' assert ( isinstance ( instrument_id , int ) is True ), f 'Argument instrument_id should be a integer. You can find the right id using the \\' get_instrument() \\' method of AlgoBullsConnection class' assert ( isinstance ( strategy_parameters , dict ) is True ), f 'Argument strategy_parameters should be a dict' assert ( isinstance ( strategy_mode , StrategyMode ) is True ), f 'Argument strategy_mode should be enum of type StrategyMode' assert ( isinstance ( candle_interval , CandleInterval )), f 'Argument candle_interval should be an enum of type CandleInterval' # Setup config for Backtesting strategy_config = { 'trading_start_date' : start_timestamp . date (), 'trading_start_time' : start_timestamp . time (), 'trading_end_date' : end_timestamp . date (), 'trading_end_time' : end_timestamp . time (), 'instrument' : instrument_id , 'parameters' : json . dumps ( strategy_parameters ), 'candle_interval' : candle_interval . value , 'strategy_mode' : strategy_mode } print ( 'Setting Strategy Config...' , end = ' ' ) self . api . set_strategy_config ( strategy_code = strategy_code , strategy_config = strategy_config ) print ( 'Success.' ) # Submit Backtesting job print ( 'Submitting Backtesting Job...' , end = ' ' ) response = self . api . start_strategy_algotrading ( strategy_code = strategy_code , trading_type = TradingType . BACKTESTING ) print ( 'Success.' ) if response . get ( 'success' ) is True : return AlgoBullsJobSubmissionResponse ( response [ 'data' ] . upper ()) else : return AlgoBullsJobSubmissionResponse . ERROR , response create_strategy ( self , strategy , overwrite = False ) \u00b6 Method to upload new strategy. All strategies are unique by name, per customer. If customer tries to upload strategy with the same name as an already existing strategy - if overwrite is False: - AlgoBullsAPIBadRequest Exception will be thrown. No change would be done in the backend database. If overwrite is True, - Existing strategy with strategy_name would be overwritten. No exception will be thrown. Source code in pyalgotrading/algobulls/connection.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def create_strategy ( self , strategy , overwrite = False ): \"\"\" Method to upload new strategy. All strategies are unique by name, per customer. If customer tries to upload strategy with the same name as an already existing strategy - if overwrite is False: - AlgoBullsAPIBadRequest Exception will be thrown. No change would be done in the backend database. If overwrite is True, - Existing strategy with strategy_name would be overwritten. No exception will be thrown. \"\"\" # Sanity checks assert issubclass ( strategy , StrategyBase ), f 'strategy should be a subclass of class StrategyBase. Got class of type: type { strategy } ' # Validate class by creating an instance print ( 'Validating Strategy...' ) strategy () # Get source code, and upload as new strategy (if strategy_code is None) else edit same strategy strategy_name = strategy . name () strategy_details = inspect . getsource ( strategy ) abc_version = strategy . versions_supported () . value # If strategy code is None, create a new strategy object try : response = self . api . create_strategy ( strategy_name = strategy_name , strategy_details = strategy_details , abc_version = abc_version ) except AlgoBullsAPIBadRequest as ex : if overwrite is True : # If strategy code is available, update the existing strategy response = self . api . update_strategy ( strategy_name = strategy_name , strategy_details = strategy_details , abc_version = abc_version ) else : raise ex return response get_all_strategies ( self ) \u00b6 Fetch all available strategies Returns: Type Description list of available strategies Source code in pyalgotrading/algobulls/connection.py 84 85 86 87 88 89 90 91 92 93 94 def get_all_strategies ( self ): \"\"\" Fetch all available strategies Returns: list of available strategies \"\"\" response = self . api . get_all_strategies () if isinstance ( response [ 'data' ], list ): return pd . DataFrame ( response [ 'data' ]) else : return response get_authorization_url ( self ) \u00b6 Fetches the authorization URL Returns: Type Description authorization URL Source code in pyalgotrading/algobulls/connection.py 26 27 28 29 30 31 32 33 34 def get_authorization_url ( self ): \"\"\" Fetches the authorization URL Returns: authorization URL \"\"\" url = 'https://devel.appv2.algobulls.com/user/login' # TODO: Update this when we move out of beta print ( f 'Please login to this URL with your AlgoBulls credentials and get your developer access token: { url } ' ) return url get_backtesting_job_status ( self , strategy_code ) \u00b6 Gets BACKTESTING job status for given strategy_code Source code in pyalgotrading/algobulls/connection.py 241 242 243 244 245 246 def get_backtesting_job_status ( self , strategy_code ): \"\"\" Gets BACKTESTING job status for given strategy_code \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' return self . get_job_status ( strategy_code , TradingType . BACKTESTING ) get_backtesting_logs ( self , strategy_code ) \u00b6 Fetch backtesting logs Parameters: Name Type Description Default strategy_code required Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 260 261 262 263 264 265 266 267 268 269 270 def get_backtesting_logs ( self , strategy_code ): \"\"\" Fetch backtesting logs Args: strategy_code: Returns: report details \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' return self . get_report ( strategy_code , trading_type = TradingType . BACKTESTING , report_type = TradingReportType . LOGS ) get_backtesting_report_order_history ( self , strategy_code ) \u00b6 Fetch backtesting order history Parameters: Name Type Description Default strategy_code strategy code required Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 297 298 299 300 301 302 303 304 305 306 307 def get_backtesting_report_order_history ( self , strategy_code ): \"\"\" Fetch backtesting order history Args: strategy_code: strategy code Returns: report details \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' return self . get_report ( strategy_code = strategy_code , trading_type = TradingType . BACKTESTING , report_type = TradingReportType . ORDER_HISTORY ) get_backtesting_report_pnl_table ( self , strategy_code , show_all_rows = False ) \u00b6 Fetch backtesting Profit / Loss details Parameters: Name Type Description Default strategy_code strategy code required show_all_rows True or False False Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 272 273 274 275 276 277 278 279 280 281 282 283 def get_backtesting_report_pnl_table ( self , strategy_code , show_all_rows = False ): \"\"\" Fetch backtesting Profit / Loss details Args: strategy_code: strategy code show_all_rows: True or False Returns: report details \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' return self . get_report ( strategy_code = strategy_code , trading_type = TradingType . BACKTESTING , report_type = TradingReportType . PNL_TABLE , render_as_dataframe = True , show_all_rows = show_all_rows ) get_backtesting_report_statistics ( self , strategy_code ) \u00b6 Fetch backtesting report statistics Parameters: Name Type Description Default strategy_code strategy code required Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 285 286 287 288 289 290 291 292 293 294 295 def get_backtesting_report_statistics ( self , strategy_code ): \"\"\" Fetch backtesting report statistics Args: strategy_code: strategy code Returns: report details \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' return self . get_report ( strategy_code = strategy_code , trading_type = TradingType . BACKTESTING , report_type = TradingReportType . STATS_TABLE , render_as_dataframe = True ) get_job_status ( self , strategy_code , trading_type , broker = None ) \u00b6 Gets job status for given strategy_code and trading_type Source code in pyalgotrading/algobulls/connection.py 128 129 130 131 132 133 134 135 136 137 138 139 140 def get_job_status ( self , strategy_code , trading_type , broker = None ): \"\"\" Gets job status for given strategy_code and trading_type \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' assert ( isinstance ( trading_type , TradingType ) is True ), f 'Argument trading_type should be an enum of type { TradingType . __name__ } ' assert ( broker is None or isinstance ( broker , AlgoBullsSupportedBrokers ) is True ), f 'Argument broker should be None or an enum of type { AlgoBullsSupportedBrokers . __name__ } ' response = self . api . get_job_status ( strategy_code = strategy_code , trading_type = trading_type , broker = broker . value ) if response . get ( 'success' ) is True : return AlgoBullsJobStatus ( response [ 'data' ] . upper ()) else : return AlgoBullsJobStatus . JOB_STATUS_UNKNOWN , response get_papertrading_job_status ( self , strategy_code ) \u00b6 Get papertrading job status Parameters: Name Type Description Default strategy_code required Returns: Type Description job status Source code in pyalgotrading/algobulls/connection.py 354 355 356 357 358 359 360 361 362 363 364 def get_papertrading_job_status ( self , strategy_code ): \"\"\" Get papertrading job status Args: strategy_code: Returns: job status \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' return self . get_job_status ( strategy_code , TradingType . PAPERTRADING ) get_papertrading_logs ( self , strategy_code ) \u00b6 Fetch papertesting logs Parameters: Name Type Description Default strategy_code strategy code required Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 378 379 380 381 382 383 384 385 386 387 388 def get_papertrading_logs ( self , strategy_code ): \"\"\" Fetch papertesting logs Args: strategy_code: strategy code Returns: report details \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' return self . get_report ( strategy_code = strategy_code , trading_type = TradingType . PAPERTRADING , report_type = TradingReportType . LOGS ) get_papertrading_report_order_history ( self , strategy_code ) \u00b6 Fetch papertesting prder history Parameters: Name Type Description Default strategy_code strategy code required Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 415 416 417 418 419 420 421 422 423 424 425 def get_papertrading_report_order_history ( self , strategy_code ): \"\"\" Fetch papertesting prder history Args: strategy_code: strategy code Returns: report details \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' return self . get_report ( strategy_code = strategy_code , trading_type = TradingType . PAPERTRADING , report_type = TradingReportType . ORDER_HISTORY ) get_papertrading_report_pnl_table ( self , strategy_code , show_all_rows = False ) \u00b6 Fetch papertesting Profit / Loss details Parameters: Name Type Description Default strategy_code strategy code required show_all_rows True or False False Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 390 391 392 393 394 395 396 397 398 399 400 401 def get_papertrading_report_pnl_table ( self , strategy_code , show_all_rows = False ): \"\"\" Fetch papertesting Profit / Loss details Args: strategy_code: strategy code show_all_rows: True or False Returns: report details \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' return self . get_report ( strategy_code = strategy_code , trading_type = TradingType . PAPERTRADING , report_type = TradingReportType . PNL_TABLE , render_as_dataframe = True , show_all_rows = show_all_rows ) get_papertrading_report_statistics ( self , strategy_code ) \u00b6 Fetch papertesting report statistics Parameters: Name Type Description Default strategy_code strategy code required Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 403 404 405 406 407 408 409 410 411 412 413 def get_papertrading_report_statistics ( self , strategy_code ): \"\"\" Fetch papertesting report statistics Args: strategy_code: strategy code Returns: report details \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' return self . get_report ( strategy_code = strategy_code , trading_type = TradingType . PAPERTRADING , report_type = TradingReportType . STATS_TABLE , render_as_dataframe = True ) get_realtrading_job_status ( self , broker , strategy_code ) \u00b6 Fetch realtrading job status Parameters: Name Type Description Default broker broker name required strategy_code strategy code required Returns: Type Description job status Source code in pyalgotrading/algobulls/connection.py 474 475 476 477 478 479 480 481 482 483 484 485 486 487 def get_realtrading_job_status ( self , broker , strategy_code ): \"\"\" Fetch realtrading job status Args: broker: broker name strategy_code: strategy code Returns: job status \"\"\" assert ( isinstance ( broker , AlgoBullsSupportedBrokers ) is True ), f 'Argument broker should be an enum of type { AlgoBullsSupportedBrokers . __name__ } ' assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' return self . get_job_status ( strategy_code , TradingType . REALTRADING , broker = broker ) get_realtrading_logs ( self , broker , strategy_code ) \u00b6 Fetch realtrading logs Parameters: Name Type Description Default broker broker name required strategy_code strategy code required Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 504 505 506 507 508 509 510 511 512 513 514 515 516 517 def get_realtrading_logs ( self , broker , strategy_code ): \"\"\" Fetch realtrading logs Args: broker: broker name strategy_code: strategy code Returns: report details \"\"\" assert ( isinstance ( broker , AlgoBullsSupportedBrokers ) is True ), f 'Argument broker should be an enum of type { AlgoBullsSupportedBrokers . __name__ } ' assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' return self . get_report ( strategy_code = strategy_code , trading_type = TradingType . REALTRADING , report_type = TradingReportType . LOGS , broker = broker ) get_realtrading_report_order_history ( self , broker , strategy_code ) \u00b6 Fetch realtrading order history Parameters: Name Type Description Default broker broker name required strategy_code strategy code required Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 550 551 552 553 554 555 556 557 558 559 560 561 562 563 def get_realtrading_report_order_history ( self , broker , strategy_code ): \"\"\" Fetch realtrading order history Args: broker: broker name strategy_code: strategy code Returns: report details \"\"\" assert ( isinstance ( broker , AlgoBullsSupportedBrokers ) is True ), f 'Argument broker should be an enum of type { AlgoBullsSupportedBrokers . __name__ } ' assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' return self . get_report ( strategy_code = strategy_code , trading_type = TradingType . REALTRADING , report_type = TradingReportType . ORDER_HISTORY , broker = broker ) get_realtrading_report_pnl_table ( self , broker , strategy_code , show_all_rows = False ) \u00b6 Fetch realtrading Profit / Loss table Parameters: Name Type Description Default broker broker name required strategy_code strategy code required show_all_rows True or False False Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 def get_realtrading_report_pnl_table ( self , broker , strategy_code , show_all_rows = False ): \"\"\" Fetch realtrading Profit / Loss table Args: broker: broker name strategy_code: strategy code show_all_rows: True or False Returns: report details \"\"\" assert ( isinstance ( broker , AlgoBullsSupportedBrokers ) is True ), f 'Argument broker should be an enum of type { AlgoBullsSupportedBrokers . __name__ } ' assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' return self . get_report ( strategy_code = strategy_code , trading_type = TradingType . REALTRADING , report_type = TradingReportType . PNL_TABLE , render_as_dataframe = True , show_all_rows = show_all_rows , broker = broker ) get_realtrading_report_statistics ( self , broker , strategy_code ) \u00b6 Fetch realtrading report statistics Parameters: Name Type Description Default broker broker name required strategy_code strategy code required Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 535 536 537 538 539 540 541 542 543 544 545 546 547 548 def get_realtrading_report_statistics ( self , broker , strategy_code ): \"\"\" Fetch realtrading report statistics Args: broker: broker name strategy_code: strategy code Returns: report details \"\"\" assert ( isinstance ( broker , AlgoBullsSupportedBrokers ) is True ), f 'Argument broker should be an enum of type { AlgoBullsSupportedBrokers . __name__ } ' assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' return self . get_report ( strategy_code = strategy_code , trading_type = TradingType . REALTRADING , report_type = TradingReportType . STATS_TABLE , render_as_dataframe = True , broker = broker ) get_report ( self , strategy_code , trading_type , report_type , render_as_dataframe = False , show_all_rows = False , broker = None ) \u00b6 Fetch the report of a strategy Parameters: Name Type Description Default strategy_code strategy code required trading_type trading type required report_type report type required render_as_dataframe True or False False show_all_rows True or False False broker broker name None Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 def get_report ( self , strategy_code , trading_type , report_type , render_as_dataframe = False , show_all_rows = False , broker = None ): \"\"\" Fetch the report of a strategy Args: strategy_code: strategy code trading_type: trading type report_type: report type render_as_dataframe: True or False show_all_rows: True or False broker: broker name Returns: report details \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' assert ( isinstance ( trading_type , TradingType ) is True ), f 'Argument trading_type should be an enum of type { TradingType . __name__ } ' assert ( isinstance ( report_type , TradingReportType ) is True ), f 'Argument report_type should be an enum of type { TradingReportType . __name__ } ' assert ( isinstance ( render_as_dataframe , bool ) is True ), f 'Argument render_as_dataframe should be a bool' assert ( isinstance ( show_all_rows , bool ) is True ), f 'Argument show_all_Rows should be a bool' assert ( broker is None or isinstance ( broker , AlgoBullsSupportedBrokers ) is True ), f 'Argument broker should be None or an enum of type { AlgoBullsSupportedBrokers . __name__ } ' response = self . api . get_reports ( strategy_code = strategy_code , trading_type = trading_type , report_type = report_type , broker = broker . value ) if response . get ( 'success' ) is True : if render_as_dataframe : if show_all_rows : pandas_dataframe_all_rows () _response = pd . DataFrame ( response [ 'data' ]) else : _response = response [ 'data' ] return _response else : return AlgoBullsJobSubmissionResponse . ERROR , response get_strategy_details ( self , strategy_code ) \u00b6 Fetch the strategy details of a particular strategy Parameters: Name Type Description Default strategy_code strategy code required Returns: Type Description strategy program / code Source code in pyalgotrading/algobulls/connection.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def get_strategy_details ( self , strategy_code ): \"\"\" Fetch the strategy details of a particular strategy Args: strategy_code: strategy code Returns: strategy program / code \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' try : response = self . api . get_strategy_details ( strategy_code ) strategy_code = response [ 'data' ] return strategy_code except AlgoBullsAPIBadRequest : print ( f 'ERROR: No strategy found with ID: { strategy_code } ' ) papertrade ( self , strategy_code , start_time , end_time , instrument_id , strategy_parameters , candle_interval , strategy_mode =< StrategyMode . INTRADAY : 0 > ) \u00b6 Start a paper trading session Parameters: Name Type Description Default strategy_code strategy code required start_time start time required end_time end time required instrument_id instrument key required strategy_parameters parameters required candle_interval candle interval required strategy_mode intraday or delivery <StrategyMode.INTRADAY: 0> Returns: Type Description job status Source code in pyalgotrading/algobulls/connection.py 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 def papertrade ( self , strategy_code , start_time , end_time , instrument_id , strategy_parameters , candle_interval , strategy_mode = StrategyMode . INTRADAY ): \"\"\" Start a paper trading session Args: strategy_code: strategy code start_time: start time end_time: end time instrument_id: instrument key strategy_parameters: parameters candle_interval: candle interval strategy_mode: intraday or delivery Returns: job status \"\"\" # Sanity checks - Validate config parameters assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' assert ( isinstance ( start_time , time ) is True ), f 'Argument start_timestamp should be an instance of type datetime.datetime' assert ( isinstance ( end_time , time ) is True ), f 'Argument start_timestamp should be an instance of type datetime.datetime' assert ( isinstance ( instrument_id , int ) is True ), f 'Argument instrument_id should be a integer. You can find the right id using the \\' get_instrument() \\' method of AlgoBullsConnection class' assert ( isinstance ( strategy_parameters , dict ) is True ), f 'Argument strategy_parameters should be a dict' assert ( isinstance ( strategy_mode , StrategyMode ) is True ), f 'Argument strategy_mode should be enum of type StrategyMode' assert ( isinstance ( candle_interval , CandleInterval )), f 'Argument candle_interval should be an enum of type CandleInterval' # Setup config for Paper Trading strategy_config = { 'trading_start_time' : start_time , 'trading_end_time' : end_time , 'instrument' : instrument_id , 'parameters' : json . dumps ( strategy_parameters ), 'candle_interval' : candle_interval . value , 'strategy_mode' : strategy_mode . value } print ( 'Setting Strategy Config...' , end = ' ' ) self . api . set_strategy_config ( strategy_code = strategy_code , strategy_config = strategy_config ) print ( 'Success.' ) # Submit Paper Trading job print ( 'Submitting Paper Trading Job...' , end = ' ' ) response = self . api . start_strategy_algotrading ( strategy_code = strategy_code , trading_type = TradingType . PAPERTRADING ) print ( 'Success.' ) if response . get ( 'success' ) is True : return AlgoBullsJobSubmissionResponse ( response [ 'data' ] . upper ()) else : return AlgoBullsJobSubmissionResponse . ERROR , response realtrade ( self , broker , strategy_code , start_time , end_time , instrument_id , strategy_parameters , candle_interval , strategy_mode =< StrategyMode . INTRADAY : 0 > ) \u00b6 Start a realtrading session Parameters: Name Type Description Default broker broker name required strategy_code strategy code required start_time start time required end_time end time required instrument_id instrument key required strategy_parameters parameters required candle_interval candle interval required strategy_mode intraday or delivery <StrategyMode.INTRADAY: 0> Returns: Type Description job status Source code in pyalgotrading/algobulls/connection.py 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 def realtrade ( self , broker , strategy_code , start_time , end_time , instrument_id , strategy_parameters , candle_interval , strategy_mode = StrategyMode . INTRADAY ): \"\"\" Start a realtrading session Args: broker: broker name strategy_code: strategy code start_time: start time end_time: end time instrument_id: instrument key strategy_parameters: parameters candle_interval: candle interval strategy_mode: intraday or delivery Returns: job status \"\"\" # Sanity checks - Validate config parameters assert ( isinstance ( broker , AlgoBullsSupportedBrokers ) is True ), f 'Argument broker should be an enum of type { AlgoBullsSupportedBrokers . __name__ } ' assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' assert ( isinstance ( start_time , time ) is True ), f 'Argument start_time should be an instance of type datetime.time' assert ( isinstance ( end_time , time ) is True ), f 'Argument end_time should be an instance of type datetime.time' assert ( isinstance ( instrument_id , int ) is True ), f 'Argument instrument_id should be a integer. You can find the right id using the \\' get_instrument() \\' method of AlgoBullsConnection class' assert ( isinstance ( strategy_parameters , dict ) is True ), f 'Argument strategy_parameters should be a dict' assert ( isinstance ( strategy_mode , StrategyMode ) is True ), f 'Argument strategy_mode should be enum of type StrategyMode' assert ( isinstance ( candle_interval , CandleInterval )), f 'Argument candle_interval should be an enum of type CandleInterval' # Setup config for backtesting strategy_config = { 'trading_start_time' : start_time , 'trading_end_time' : end_time , 'instrument' : instrument_id , 'parameters' : json . dumps ( strategy_parameters ), 'candle_interval' : candle_interval . value , 'strategy_mode' : strategy_mode . value } print ( 'Setting Strategy Config...' , end = ' ' ) self . api . set_strategy_config ( strategy_code = strategy_code , strategy_config = strategy_config ) print ( 'Success.' ) # Submit Real Trading job print ( 'Submitting Real Trading Job...' , end = ' ' ) response = self . api . start_strategy_algotrading ( strategy_code = strategy_code , trading_type = TradingType . REALTRADING , broker = broker . value ) print ( 'Success.' ) if response . get ( 'success' ) is True : return AlgoBullsJobSubmissionResponse ( response [ 'data' ] . upper ()) else : return AlgoBullsJobSubmissionResponse . ERROR , response search_instrument ( self , instrument ) \u00b6 Search for an instrument Parameters: Name Type Description Default instrument instrument key required Returns: Type Description True or False Source code in pyalgotrading/algobulls/connection.py 114 115 116 117 118 119 120 121 122 123 124 125 126 def search_instrument ( self , instrument ): \"\"\" Search for an instrument Args: instrument: instrument key Returns: True or False \"\"\" assert ( isinstance ( instrument , str ) is True ), f 'Argument instrument should be a string' response = self . api . search_instrument ( instrument )[ 'details' ] return response set_access_token ( self , access_token ) \u00b6 Set the access token Parameters: Name Type Description Default access_token access token required Returns: Type Description None Source code in pyalgotrading/algobulls/connection.py 36 37 38 39 40 41 42 43 44 45 46 def set_access_token ( self , access_token ): \"\"\" Set the access token Args: access_token: access token Returns: None \"\"\" assert ( isinstance ( access_token , str ) is True ), f 'Argument access_token should be a string' self . api . set_access_token ( access_token ) stop_backtesting_job ( self , strategy_code ) \u00b6 Stops the BACKTESTING job Parameters: Name Type Description Default strategy_code Strategy Code / ID required Returns: Type Description None Source code in pyalgotrading/algobulls/connection.py 248 249 250 251 252 253 254 255 256 257 258 def stop_backtesting_job ( self , strategy_code ): \"\"\" Stops the BACKTESTING job Args: strategy_code: Strategy Code / ID Returns: None \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' return self . stop_job ( strategy_code = strategy_code , trading_type = TradingType . BACKTESTING ) stop_job ( self , strategy_code , trading_type , broker = None ) \u00b6 Stops a job Parameters: Name Type Description Default strategy_code strategy code required trading_type trading type required broker broker name None Returns: Type Description job status Source code in pyalgotrading/algobulls/connection.py 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 def stop_job ( self , strategy_code , trading_type , broker = None ): \"\"\" Stops a job Args: strategy_code: strategy code trading_type: trading type broker: broker name Returns: job status \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' assert ( isinstance ( trading_type , TradingType ) is True ), f 'Argument trading_type should be an enum of type { TradingType . __name__ } ' assert ( broker is None or isinstance ( broker , AlgoBullsSupportedBrokers ) is True ), f 'Argument broker should be None or an enum of type { AlgoBullsSupportedBrokers . __name__ } ' response = self . api . stop_strategy_algotrading ( strategy_code = strategy_code , trading_type = trading_type , broker = broker . value ) if response . get ( 'success' ) is True : return AlgoBullsJobSubmissionResponse ( response [ 'data' ] . upper ()) else : return AlgoBullsJobSubmissionResponse . ERROR , response stop_papertrading_job ( self , strategy_code ) \u00b6 Stop the papertrading session Parameters: Name Type Description Default strategy_code strategy code required Returns: Type Description None Source code in pyalgotrading/algobulls/connection.py 366 367 368 369 370 371 372 373 374 375 376 def stop_papertrading_job ( self , strategy_code ): \"\"\" Stop the papertrading session Args: strategy_code: strategy code Returns: None \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' return self . stop_job ( strategy_code = strategy_code , trading_type = TradingType . PAPERTRADING ) stop_realtrading_job ( self , broker , strategy_code ) \u00b6 Stop the realtrading session Parameters: Name Type Description Default broker brker name required strategy_code strategy code required Returns: Type Description None Source code in pyalgotrading/algobulls/connection.py 489 490 491 492 493 494 495 496 497 498 499 500 501 502 def stop_realtrading_job ( self , broker , strategy_code ): \"\"\" Stop the realtrading session Args: broker: brker name strategy_code: strategy code Returns: None \"\"\" assert ( isinstance ( broker , AlgoBullsSupportedBrokers ) is True ), f 'Argument broker should be an enum of type { AlgoBullsSupportedBrokers . __name__ } ' assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' return self . stop_job ( strategy_code = strategy_code , trading_type = TradingType . REALTRADING , broker = broker ) pandas_dataframe_all_rows () \u00b6 Returns: None Source code in pyalgotrading/algobulls/connection.py 566 567 568 569 570 571 572 573 574 575 def pandas_dataframe_all_rows (): \"\"\" Returns: None \"\"\" pd . set_option ( 'display.max_rows' , None ) pd . set_option ( 'display.max_columns' , None ) pd . set_option ( 'display.width' , None ) pd . set_option ( 'display.max_colwidth' , None ) exceptions \u00b6 AlgoBullsAPIBadRequest \u00b6 Exception class for HTTP status code of 400 (Bad Request) AlgoBullsAPIBaseException \u00b6 Base exception class for all API related exceptions AlgoBullsAPIInternalServerErrorException \u00b6 Exception class for HTTP status code of 500 (Internal Server Error) AlgoBullsAPIResourceNotFoundError \u00b6 Exception class for HTTP status code of 404 (Resource Not Found) AlgoBullsAPIUnauthorizedError \u00b6 Exception class for HTTP status code of 401 (Unauthorized) broker special \u00b6 broker_connection_base \u00b6 Base class for Broker Connection BrokerConnectionBase \u00b6 Base class for Broker Connection get_all_instruments ( self ) \u00b6 All instruments enlisted by the broker Returns: Type Description list of all instruments Source code in pyalgotrading/broker/broker_connection_base.py 20 21 22 23 24 25 26 27 @abstractmethod def get_all_instruments ( self ): \"\"\" All instruments enlisted by the broker Returns: list of all instruments \"\"\" raise NotImplementedError get_circuit_limits ( self , * args , ** kwargs ) \u00b6 Fetch the circuit limits Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description circuit limit value Source code in pyalgotrading/broker/broker_connection_base.py 55 56 57 58 59 60 61 62 63 64 65 66 @abstractmethod def get_circuit_limits ( self , * args , ** kwargs ): \"\"\" Fetch the circuit limits Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: circuit limit value \"\"\" raise NotImplementedError get_close_price_last_day ( self , * args , ** kwargs ) \u00b6 Fetch the closed price of the day Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description closed price value Source code in pyalgotrading/broker/broker_connection_base.py 185 186 187 188 189 190 191 192 193 194 195 196 @abstractmethod def get_close_price_last_day ( self , * args , ** kwargs ): \"\"\" Fetch the closed price of the day Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: closed price value \"\"\" raise NotImplementedError get_funds ( self , * args , ** kwargs ) \u00b6 Fetch the available funds Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description available funds value Source code in pyalgotrading/broker/broker_connection_base.py 226 227 228 229 230 231 232 233 234 235 236 237 @abstractmethod def get_funds ( self , * args , ** kwargs ): \"\"\" Fetch the available funds Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: available funds value \"\"\" raise NotImplementedError get_high_price_day ( self , * args , ** kwargs ) \u00b6 Fetch the high price of the day Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description high price value Source code in pyalgotrading/broker/broker_connection_base.py 159 160 161 162 163 164 165 166 167 168 169 170 @abstractmethod def get_high_price_day ( self , * args , ** kwargs ): \"\"\" Fetch the high price of the day Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: high price value \"\"\" raise NotImplementedError get_historical_data ( self , instrument , candle_interval , start_date , end_date ) \u00b6 Fetch the historical data Parameters: Name Type Description Default instrument instrument key required candle_interval candle interval required start_date date from which to fetch the historical data required end_date date till which to fetch the historical data required Returns: Type Description historical data Source code in pyalgotrading/broker/broker_connection_base.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 @abstractmethod def get_historical_data ( self , instrument , candle_interval , start_date , end_date ): \"\"\" Fetch the historical data Args: instrument: instrument key candle_interval: candle interval start_date: date from which to fetch the historical data end_date: date till which to fetch the historical data Returns: historical data \"\"\" raise NotImplementedError get_instrument ( self , * args , ** kwargs ) \u00b6 Fetch a single instrument Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description a single instrument Source code in pyalgotrading/broker/broker_connection_base.py 29 30 31 32 33 34 35 36 37 38 39 40 @abstractmethod def get_instrument ( self , * args , ** kwargs ): \"\"\" Fetch a single instrument Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: a single instrument \"\"\" raise NotImplementedError get_low_price_day ( self , * args , ** kwargs ) \u00b6 Fetch the low price of the day Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description low price value Source code in pyalgotrading/broker/broker_connection_base.py 172 173 174 175 176 177 178 179 180 181 182 183 @abstractmethod def get_low_price_day ( self , * args , ** kwargs ): \"\"\" Fetch the low price of the day Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: low price value \"\"\" raise NotImplementedError get_ltp ( self , * args , ** kwargs ) \u00b6 Fetch the Last Trading Price (LTP) Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description ltp value Source code in pyalgotrading/broker/broker_connection_base.py 68 69 70 71 72 73 74 75 76 77 78 79 @abstractmethod def get_ltp ( self , * args , ** kwargs ): \"\"\" Fetch the Last Trading Price (LTP) Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: ltp value \"\"\" raise NotImplementedError get_ltq ( self , * args , ** kwargs ) \u00b6 Fetch the Last Trading Quantity (LTQ) Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description ltq value Source code in pyalgotrading/broker/broker_connection_base.py 94 95 96 97 98 99 100 101 102 103 104 105 @abstractmethod def get_ltq ( self , * args , ** kwargs ): \"\"\" Fetch the Last Trading Quantity (LTQ) Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: ltq value \"\"\" raise NotImplementedError get_ltt ( self , * args , ** kwargs ) \u00b6 Fetch the Last Trading Time (LTT) Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description ltt value Source code in pyalgotrading/broker/broker_connection_base.py 81 82 83 84 85 86 87 88 89 90 91 92 @abstractmethod def get_ltt ( self , * args , ** kwargs ): \"\"\" Fetch the Last Trading Time (LTT) Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: ltt value \"\"\" raise NotImplementedError get_margins ( self , * args , ** kwargs ) \u00b6 Fetch the margins Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description margin value Source code in pyalgotrading/broker/broker_connection_base.py 213 214 215 216 217 218 219 220 221 222 223 224 @abstractmethod def get_margins ( self , * args , ** kwargs ): \"\"\" Fetch the margins Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: margin value \"\"\" raise NotImplementedError get_market_depth ( self , * args , ** kwargs ) \u00b6 Fetch the market depth Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description market depth value Source code in pyalgotrading/broker/broker_connection_base.py 42 43 44 45 46 47 48 49 50 51 52 53 @abstractmethod def get_market_depth ( self , * args , ** kwargs ): \"\"\" Fetch the market depth Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: market depth value \"\"\" raise NotImplementedError get_name ( self ) \u00b6 Name of the broker Returns: Type Description broker name Source code in pyalgotrading/broker/broker_connection_base.py 11 12 13 14 15 16 17 18 @abstractmethod def get_name ( self ): \"\"\" Name of the broker Returns: broker name \"\"\" raise NotImplementedError get_open_price_day ( self , * args , ** kwargs ) \u00b6 Fetch the open price of the day Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description open price value Source code in pyalgotrading/broker/broker_connection_base.py 146 147 148 149 150 151 152 153 154 155 156 157 @abstractmethod def get_open_price_day ( self , * args , ** kwargs ): \"\"\" Fetch the open price of the day Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: open price value \"\"\" raise NotImplementedError get_order_status ( self , order_id ) \u00b6 Fetch the status of the order Parameters: Name Type Description Default order_id order id required Returns: Type Description the status of the order Source code in pyalgotrading/broker/broker_connection_base.py 270 271 272 273 274 275 276 277 278 279 280 @abstractmethod def get_order_status ( self , order_id ): \"\"\" Fetch the status of the order Args: order_id: order id Returns: the status of the order \"\"\" raise NotImplementedError get_profile ( self ) \u00b6 Fetch the profile Returns: Type Description profile information Source code in pyalgotrading/broker/broker_connection_base.py 239 240 241 242 243 244 245 246 @abstractmethod def get_profile ( self ): \"\"\" Fetch the profile Returns: profile information \"\"\" raise NotImplementedError get_total_buy_quantity_day ( self , * args , ** kwargs ) \u00b6 Fetch the total buy quantity for the day Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description total quantity value Source code in pyalgotrading/broker/broker_connection_base.py 107 108 109 110 111 112 113 114 115 116 117 118 @abstractmethod def get_total_buy_quantity_day ( self , * args , ** kwargs ): \"\"\" Fetch the total buy quantity for the day Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: total quantity value \"\"\" raise NotImplementedError get_total_sell_quantity_day ( self , * args , ** kwargs ) \u00b6 Fetch the total sell quantity for the day Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description total quantity value Source code in pyalgotrading/broker/broker_connection_base.py 120 121 122 123 124 125 126 127 128 129 130 131 @abstractmethod def get_total_sell_quantity_day ( self , * args , ** kwargs ): \"\"\" Fetch the total sell quantity for the day Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: total quantity value \"\"\" raise NotImplementedError get_total_volume_day ( self , * args , ** kwargs ) \u00b6 Fetch the total volume for the day Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description total volume value Source code in pyalgotrading/broker/broker_connection_base.py 133 134 135 136 137 138 139 140 141 142 143 144 @abstractmethod def get_total_volume_day ( self , * args , ** kwargs ): \"\"\" Fetch the total volume for the day Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: total volume value \"\"\" raise NotImplementedError place_order ( self , instrument , order_transaction_type , order_type , order_code , order_variety , quantity , price = None , trigger_price = None , stoploss_trigger = None , target_trigger = None , trailing_stoploss_trigger = None ) \u00b6 Place an order Parameters: Name Type Description Default instrument instrument key required order_transaction_type buy or sell required order_type regular or bracket required order_code orde code required order_variety market / limit / stoploss market / stoploss limit required quantity quantity required price amount / value None trigger_price trigger price amount / value None stoploss_trigger stoploss trigger amount / value None target_trigger target trigger amount / value None trailing_stoploss_trigger trailing stoploss trigger amount / value None Returns: Type Description order id Source code in pyalgotrading/broker/broker_connection_base.py 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 @abstractmethod def place_order ( self , instrument , order_transaction_type , order_type , order_code , order_variety , quantity , price = None , trigger_price = None , stoploss_trigger = None , target_trigger = None , trailing_stoploss_trigger = None ): \"\"\" Place an order Args: instrument: instrument key order_transaction_type: buy or sell order_type: regular or bracket order_code: orde code order_variety: market / limit / stoploss market / stoploss limit quantity: quantity price: amount / value trigger_price: trigger price amount / value stoploss_trigger: stoploss trigger amount / value target_trigger: target trigger amount / value trailing_stoploss_trigger: trailing stoploss trigger amount / value Returns: order id \"\"\" raise NotImplementedError broker_connection_zerodha \u00b6 Module for class BrokerConnectionZerodha BrokerConnectionZerodha \u00b6 class for Broker Connection Zerodha __init__ ( self , api_key , api_secret ) special \u00b6 Init method that is used while creating an object of this class Parameters: Name Type Description Default api_key api key given by the broker required api_secret api secret to be used for making an authenticated connection with the broker required Source code in pyalgotrading/broker/broker_connection_zerodha.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def __init__ ( self , api_key , api_secret ): \"\"\" Init method that is used while creating an object of this class Args: api_key: api key given by the broker api_secret: api secret to be used for making an authenticated connection with the broker \"\"\" self . api_key = api_key self . api_secret = api_secret # Create kiteconnect instance kiteconnect = import_with_install ( package_import_name = 'kiteconnect' , package_install_name = 'kiteconnect' , package_version = '3.8.2' ) self . api = kiteconnect . KiteConnect ( api_key = self . api_key ) # Print the login url. User will use this to login to broker site and get access token print ( f 'Please login to this link to generate your request token: { self . api . login_url () } ' ) # Create other attributes self . all_instruments = None self . populate_constants () cancel_order ( self , order_id , order_type ) \u00b6 Cancel an order Parameters: Name Type Description Default order_id order id required order_type order type required Returns: Type Description Order Status Source code in pyalgotrading/broker/broker_connection_zerodha.py 379 380 381 382 383 384 385 386 387 388 389 390 def cancel_order ( self , order_id , order_type ): \"\"\" Cancel an order Args: order_id: order id order_type: order type Returns: Order Status \"\"\" _variety = BrokerConnectionZerodha . ORDER_TYPE_MAP [ order_type ] # What we call as 'Order Type', Zerodha calls it as 'variety' return self . api . cancel_order ( variety = _variety , order_id = order_id ) get_all_instruments ( self ) \u00b6 Fetches all instruments Returns: Type Description list of all instruments Source code in pyalgotrading/broker/broker_connection_zerodha.py 86 87 88 89 90 91 92 93 def get_all_instruments ( self ): \"\"\" Fetches all instruments Returns: list of all instruments \"\"\" self . all_instruments = pd . DataFrame ( self . api . instruments ()) return self . all_instruments get_circuit_limits ( self , segment , tradingsymbol ) \u00b6 Fetch the circuit limits Parameters: Name Type Description Default segment segment required tradingsymbol trading symbol required Returns: Type Description circuit limit value Source code in pyalgotrading/broker/broker_connection_zerodha.py 138 139 140 141 142 143 144 145 146 147 148 149 150 151 def get_circuit_limits ( self , segment , tradingsymbol ): \"\"\" Fetch the circuit limits Args: segment: segment tradingsymbol: trading symbol Returns: circuit limit value \"\"\" quote = self . get_quote ( segment , tradingsymbol ) lower_circuit_limit = quote [ 'lower_circuit_limit' ] upper_circuit_limit = quote [ 'upper_circuit_limit' ] return lower_circuit_limit , upper_circuit_limit get_close_price_last_day ( self , segment , tradingsymbol ) \u00b6 Fetch the closed price of the day Parameters: Name Type Description Default segment segment required tradingsymbol trading symbol required Returns: Type Description closed price value Source code in pyalgotrading/broker/broker_connection_zerodha.py 279 280 281 282 283 284 285 286 287 288 289 290 291 def get_close_price_last_day ( self , segment , tradingsymbol ): \"\"\" Fetch the closed price of the day Args: segment: segment tradingsymbol: trading symbol Returns: closed price value \"\"\" quote = self . get_quote ( segment , tradingsymbol ) close_price_day = quote [ 'ohlc' ][ 'close' ] return close_price_day get_funds ( self , segment ) \u00b6 Fetch the available funds Parameters: Name Type Description Default segment segment required Returns: Type Description available funds value Source code in pyalgotrading/broker/broker_connection_zerodha.py 321 322 323 324 325 326 327 328 329 330 331 332 def get_funds ( self , segment ): \"\"\" Fetch the available funds Args: segment: segment Returns: available funds value \"\"\" list_permissible_segments = [ 'equity' , 'commodity' ] assert ( segment in list_permissible_segments ), f 'segment should be one of { list_permissible_segments } ' return self . api . margins ( segment = segment )[ 'net' ] get_high_price_day ( self , segment , tradingsymbol ) \u00b6 Fetch the high price of the day Parameters: Name Type Description Default segment segment required tradingsymbol trading symbol required Returns: Type Description high price value Source code in pyalgotrading/broker/broker_connection_zerodha.py 251 252 253 254 255 256 257 258 259 260 261 262 263 def get_high_price_day ( self , segment , tradingsymbol ): \"\"\" Fetch the high price of the day Args: segment: segment tradingsymbol: trading symbol Returns: high price value \"\"\" quote = self . get_quote ( segment , tradingsymbol ) high_price_day = quote [ 'ohlc' ][ 'high' ] return high_price_day get_historical_data ( self , instrument , candle_interval , start_date , end_date ) \u00b6 Fetch the historical data Parameters: Name Type Description Default instrument instrument key required candle_interval candle interval required start_date date from which to fetch the historical data required end_date date till which to fetch the historical data required Returns: Type Description historical data Source code in pyalgotrading/broker/broker_connection_zerodha.py 293 294 295 296 297 298 299 300 301 302 303 304 305 306 def get_historical_data ( self , instrument , candle_interval , start_date , end_date ): \"\"\" Fetch the historical data Args: instrument: instrument key candle_interval: candle interval start_date: date from which to fetch the historical data end_date: date till which to fetch the historical data Returns: historical data \"\"\" return pd . DataFrame ( self . api . historical_data ( instrument [ 'instrument_token' ], from_date = start_date , to_date = end_date , interval = candle_interval )) \\ . reindex ([ 'date' , 'open' , 'high' , 'low' , 'close' , 'volume' ], axis = \"columns\" ) . rename ( columns = { 'date' : 'timestamp' }) get_instrument ( self , segment , tradingsymbol ) \u00b6 Fetch an instrument Parameters: Name Type Description Default segment segment required tradingsymbol trading symbol required Returns: Type Description instrument Source code in pyalgotrading/broker/broker_connection_zerodha.py 95 96 97 98 99 100 101 102 103 104 105 106 107 def get_instrument ( self , segment , tradingsymbol ): \"\"\" Fetch an instrument Args: segment: segment tradingsymbol: trading symbol Returns: instrument \"\"\" if self . all_instruments is None : self . all_instruments = self . get_all_instruments () return self . all_instruments [( self . all_instruments . segment == segment ) & ( self . all_instruments . tradingsymbol == tradingsymbol )] . iloc [ 0 ] get_low_price_day ( self , segment , tradingsymbol ) \u00b6 Fetch the low price of the day Parameters: Name Type Description Default segment segment required tradingsymbol trading symbol required Returns: Type Description low price value Source code in pyalgotrading/broker/broker_connection_zerodha.py 265 266 267 268 269 270 271 272 273 274 275 276 277 def get_low_price_day ( self , segment , tradingsymbol ): \"\"\" Fetch the low price of the day Args: segment: segment tradingsymbol: trading symbol Returns: low price value \"\"\" quote = self . get_quote ( segment , tradingsymbol ) low_price_day = quote [ 'ohlc' ][ 'low' ] return low_price_day get_ltp ( self , segment , tradingsymbol ) \u00b6 Fetch the Last Trading Price (LTP) Parameters: Name Type Description Default segment segment required tradingsymbol trading symbol required Returns: Type Description ltp value Source code in pyalgotrading/broker/broker_connection_zerodha.py 153 154 155 156 157 158 159 160 161 162 163 164 165 def get_ltp ( self , segment , tradingsymbol ): \"\"\" Fetch the Last Trading Price (LTP) Args: segment: segment tradingsymbol: trading symbol Returns: ltp value \"\"\" quote = self . get_quote ( segment , tradingsymbol ) ltp = quote [ 'last_price' ] return ltp get_ltq ( self , segment , tradingsymbol ) \u00b6 Fetch the Last Trading Quantity (LTQ) Parameters: Name Type Description Default segment segment required tradingsymbol trading symbol required Returns: Type Description ltq value Source code in pyalgotrading/broker/broker_connection_zerodha.py 181 182 183 184 185 186 187 188 189 190 191 192 193 def get_ltq ( self , segment , tradingsymbol ): \"\"\" Fetch the Last Trading Quantity (LTQ) Args: segment: segment tradingsymbol: trading symbol Returns: ltq value \"\"\" quote = self . get_quote ( segment , tradingsymbol ) ltq = quote [ 'last_quantity' ] return ltq get_ltt ( self , segment , tradingsymbol ) \u00b6 Fetch the Last Trading Time (LTT) Parameters: Name Type Description Default segment segment required tradingsymbol trading symbol required Returns: Type Description ltt value Source code in pyalgotrading/broker/broker_connection_zerodha.py 167 168 169 170 171 172 173 174 175 176 177 178 179 def get_ltt ( self , segment , tradingsymbol ): \"\"\" Fetch the Last Trading Time (LTT) Args: segment: segment tradingsymbol: trading symbol Returns: ltt value \"\"\" quote = self . get_quote ( segment , tradingsymbol ) ltt = quote [ 'last_trade_time' ] return ltt get_margins ( self , segment ) \u00b6 Fetch the margins Parameters: Name Type Description Default segment segment required Returns: Type Description margin value Source code in pyalgotrading/broker/broker_connection_zerodha.py 308 309 310 311 312 313 314 315 316 317 318 319 def get_margins ( self , segment ): \"\"\" Fetch the margins Args: segment: segment Returns: margin value \"\"\" list_permissible_segments = [ 'equity' , 'commodity' ] assert ( segment in list_permissible_segments ), f 'segment should be one of { list_permissible_segments } ' return self . api . margins ( segment = segment ) get_market_depth ( self , segment , tradingsymbol ) \u00b6 Fetch the market depth Parameters: Name Type Description Default segment segment required tradingsymbol trading symbol required Returns: Type Description market depth value Source code in pyalgotrading/broker/broker_connection_zerodha.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 def get_market_depth ( self , segment , tradingsymbol ): \"\"\" Fetch the market depth Args: segment: segment tradingsymbol: trading symbol Returns: market depth value \"\"\" quote = self . get_quote ( segment , tradingsymbol ) buy_market_depth = pd . DataFrame ( quote [ 'depth' ][ 'buy' ]) sell_market_depth = pd . DataFrame ( quote [ 'depth' ][ 'sell' ]) return buy_market_depth , sell_market_depth get_name ( self ) \u00b6 Fetch the name of the broker Returns: Type Description name of the broker Source code in pyalgotrading/broker/broker_connection_zerodha.py 43 44 45 46 47 48 49 def get_name ( self ): \"\"\" Fetch the name of the broker Returns: name of the broker \"\"\" return 'ZERODHA' get_open_price_day ( self , segment , tradingsymbol ) \u00b6 Fetch the open price of the day Parameters: Name Type Description Default segment segment required tradingsymbol trading symbol required Returns: Type Description open price value Source code in pyalgotrading/broker/broker_connection_zerodha.py 237 238 239 240 241 242 243 244 245 246 247 248 249 def get_open_price_day ( self , segment , tradingsymbol ): \"\"\" Fetch the open price of the day Args: segment: segment tradingsymbol: trading symbol Returns: open price value \"\"\" quote = self . get_quote ( segment , tradingsymbol ) open_price_day = quote [ 'ohlc' ][ 'open' ] return open_price_day get_order_status ( self , order_id ) \u00b6 Fetch the status of the order Parameters: Name Type Description Default order_id order id required Returns: Type Description the status of the order Source code in pyalgotrading/broker/broker_connection_zerodha.py 368 369 370 371 372 373 374 375 376 377 def get_order_status ( self , order_id ): \"\"\" Fetch the status of the order Args: order_id: order id Returns: the status of the order \"\"\" return self . api . order_history ( order_id )[ - 1 ][ 'status' ] get_profile ( self ) \u00b6 Fetch the profile Returns: Type Description profile information Source code in pyalgotrading/broker/broker_connection_zerodha.py 334 335 336 337 338 339 340 def get_profile ( self ): \"\"\" Fetch the profile Returns: profile information \"\"\" return self . api . profile () get_quote ( self , segment , tradingsymbol ) \u00b6 Fetch the quote Parameters: Name Type Description Default segment required tradingsymbol required Returns: Type Description quote value Source code in pyalgotrading/broker/broker_connection_zerodha.py 109 110 111 112 113 114 115 116 117 118 119 120 121 def get_quote ( self , segment , tradingsymbol ): \"\"\" Fetch the quote Args: segment: tradingsymbol: Returns: quote value \"\"\" instrument = f ' { segment } : { tradingsymbol } ' quote = self . api . quote ([ instrument ])[ instrument ] return quote get_total_buy_quantity_day ( self , segment , tradingsymbol ) \u00b6 Fetch the total buy quantity for the day Parameters: Name Type Description Default segment segment required tradingsymbol trading symbol required Returns: Type Description total quantity value Source code in pyalgotrading/broker/broker_connection_zerodha.py 195 196 197 198 199 200 201 202 203 204 205 206 207 def get_total_buy_quantity_day ( self , segment , tradingsymbol ): \"\"\" Fetch the total buy quantity for the day Args: segment: segment tradingsymbol: trading symbol Returns: total quantity value \"\"\" quote = self . get_quote ( segment , tradingsymbol ) total_buy_quantity_day = quote [ 'buy_quantity' ] return total_buy_quantity_day get_total_sell_quantity_day ( self , segment , tradingsymbol ) \u00b6 Fetch the total sell quantity for the day Parameters: Name Type Description Default segment segment required tradingsymbol trading symbol required Returns: Type Description total quantity value Source code in pyalgotrading/broker/broker_connection_zerodha.py 209 210 211 212 213 214 215 216 217 218 219 220 221 def get_total_sell_quantity_day ( self , segment , tradingsymbol ): \"\"\" Fetch the total sell quantity for the day Args: segment: segment tradingsymbol: trading symbol Returns: total quantity value \"\"\" quote = self . get_quote ( segment , tradingsymbol ) total_sell_quantity_day = quote [ 'sell_quantity' ] return total_sell_quantity_day get_total_volume_day ( self , segment , tradingsymbol ) \u00b6 Fetch the total volume for the day Parameters: Name Type Description Default segment segment required tradingsymbol trading symbol required Returns: Type Description total volume value Source code in pyalgotrading/broker/broker_connection_zerodha.py 223 224 225 226 227 228 229 230 231 232 233 234 235 def get_total_volume_day ( self , segment , tradingsymbol ): \"\"\" Fetch the total volume for the day Args: segment: segment tradingsymbol: trading symbol Returns: total volume value \"\"\" quote = self . get_quote ( segment , tradingsymbol ) total_volume_day = quote [ 'volume' ] return total_volume_day place_order ( self , instrument , order_transaction_type , order_type , order_code , order_variety , quantity , price = None , trigger_price = None , stoploss = None , target = None , trailing_stoploss = None ) \u00b6 Place an order Parameters: Name Type Description Default instrument instrument key required order_transaction_type buy or sell required order_type regular or bracket required order_code orde code required order_variety market / limit / stoploss market / stoploss limit required quantity quantity required price amount / value None trigger_price trigger price amount / value None stoploss stoploss amount / value None target target amount / value None trailing_stoploss trailing stoploss amount / value None Returns: Type Description Order status Source code in pyalgotrading/broker/broker_connection_zerodha.py 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 def place_order ( self , instrument , order_transaction_type , order_type , order_code , order_variety , quantity , price = None , trigger_price = None , stoploss = None , target = None , trailing_stoploss = None ): \"\"\" Place an order Args: instrument: instrument key order_transaction_type: buy or sell order_type: regular or bracket order_code: orde code order_variety: market / limit / stoploss market / stoploss limit quantity: quantity price: amount / value trigger_price: trigger price amount / value stoploss: stoploss amount / value target: target amount / value trailing_stoploss: trailing stoploss amount / value Returns: Order status \"\"\" _variety = BrokerConnectionZerodha . ORDER_TYPE_MAP [ order_type ] # what we call as 'Order Type', Zerodha calls it as 'variety' _transaction_type = BrokerConnectionZerodha . ORDER_TRANSACTION_TYPE_MAP [ order_transaction_type ] _product = BrokerConnectionZerodha . ORDER_CODE_MAP [ order_code ] # what we call as 'Order Code', Zerodha calls it as 'product' _order_type = BrokerConnectionZerodha . ORDER_VARIETY_MAP [ order_variety ] # What we call as 'Order Variety', Zerodha calls it as 'order_type' return self . api . place_order ( variety = _variety , exchange = instrument . exchange , tradingsymbol = instrument . tradingsymbol , transaction_type = _transaction_type , quantity = quantity , product = _product , order_type = _order_type , price = price , trigger_price = trigger_price , squareoff = target , stoploss = stoploss , trailing_stoploss = trailing_stoploss ) populate_constants ( self ) \u00b6 Map pyalgotrading constants to broker constants :return: None Source code in pyalgotrading/broker/broker_connection_zerodha.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def populate_constants ( self ): \"\"\" Map pyalgotrading constants to broker constants :return: None \"\"\" _ = import_with_install ( package_import_name = 'kiteconnect' , package_install_name = 'kiteconnect' , package_version = '3.8.2' ) . KiteConnect BrokerConnectionZerodha . ORDER_TRANSACTION_TYPE_MAP = { BrokerOrderTransactionTypeConstants . BUY : _ . TRANSACTION_TYPE_BUY , BrokerOrderTransactionTypeConstants . SELL : _ . TRANSACTION_TYPE_SELL } BrokerConnectionZerodha . ORDER_TYPE_MAP = { BrokerOrderTypeConstants . REGULAR : _ . VARIETY_REGULAR , BrokerOrderTypeConstants . BRACKET : _ . VARIETY_BO , BrokerOrderTypeConstants . COVER : _ . VARIETY_CO , BrokerOrderTypeConstants . AMO : _ . VARIETY_AMO } BrokerConnectionZerodha . ORDER_CODE_MAP = { BrokerOrderCodeConstants . INTRADAY : _ . PRODUCT_MIS , BrokerOrderCodeConstants . DELIVERY : _ . PRODUCT_CNC } BrokerConnectionZerodha . ORDER_VARIETY_MAP = { BrokerOrderVarietyConstants . MARKET : _ . ORDER_TYPE_MARKET , BrokerOrderVarietyConstants . LIMIT : _ . ORDER_TYPE_LIMIT , BrokerOrderVarietyConstants . STOPLOSS_LIMIT : _ . ORDER_TYPE_SL , BrokerOrderVarietyConstants . STOPLOSS_MARKET : _ . ORDER_TYPE_SLM } set_access_token ( self , request_token ) \u00b6 Sets the access token Parameters: Name Type Description Default request_token the request token required Returns: Type Description None Source code in pyalgotrading/broker/broker_connection_zerodha.py 74 75 76 77 78 79 80 81 82 83 84 def set_access_token ( self , request_token ): \"\"\" Sets the access token Args: request_token: the request token Returns: None \"\"\" data = self . api . generate_session ( request_token , api_secret = self . api_secret ) self . api . set_access_token ( data [ \"access_token\" ]) utils \u00b6 Module for calculating crossover crossover ( val1_hist , val2_hist , accuracy_decimals = 2 ) \u00b6 Computes crossover of 2 data series - val1_hist and val2_hist. Parameters: Name Type Description Default val1_hist Union[Tuple, List, pandas.core.series.Series] Any object which can be converted to a list of data points. (Ex: pandas.Series, tuple, list) required val2_hist Union[Tuple, List, pandas.core.series.Series] Any object which can be converted to a list of data points. (Ex: pandas.Series, tuple, list) required accuracy_decimals int Positive integer, specifying number of decimal places to be looked into until we consider two numbers as equal. Ex: with accuracy_decimals=2, 3.456 and 3.457 are considered equal, but 3.456 and 3.466 are considered unequal. 2 Returns: Type Description int 1 if val1_hist(OHLC) cuts val2_hist upwards -1 if val1_hist cuts val2_hist downwards 0 if there is no cut between val1_hist and val2_hist Source code in pyalgotrading/broker/utils.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def crossover ( val1_hist : Union [ Tuple , List , pd . Series ], val2_hist : Union [ Tuple , List , pd . Series ], accuracy_decimals : int = 2 ) -> int : \"\"\" Computes crossover of 2 data series - val1_hist and val2_hist. Args: val1_hist: Any object which can be converted to a list of data points. (Ex: pandas.Series, tuple, list) val2_hist: Any object which can be converted to a list of data points. (Ex: pandas.Series, tuple, list) accuracy_decimals: Positive integer, specifying number of decimal places to be looked into until we consider two numbers as equal. Ex: with accuracy_decimals=2, 3.456 and 3.457 are considered equal, but 3.456 and 3.466 are considered unequal. Returns: - `1` if `val1_hist(OHLC)` cuts `val2_hist` upwards - `-1` if `val1_hist` cuts `val2_hist` downwards - `0` if there is no cut between `val1_hist` and `val2_hist` \"\"\" # This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. pass constants \u00b6 A collection of classes of type Enumeration use while programming a new strategy AlgoBullsEngineVersion \u00b6 A class of Versioning Constants AlgoBullsJobStatus \u00b6 A class of job status Constants AlgoBullsJobSubmissionResponse \u00b6 A class of responses when querying the job status AlgoBullsSupportedBrokers \u00b6 A class of supported brokers BrokerOrderCodeConstants \u00b6 A class of Order Code Constants BrokerOrderTransactionTypeConstants \u00b6 A class of Order Transaction Type Constants BrokerOrderTypeConstants \u00b6 A class of Order Type Constants BrokerOrderVarietyConstants \u00b6 A class of Order Variety Constants CandleInterval \u00b6 A class of Candle Intervals with their Alternate names PlotType \u00b6 A class of Plot Types StrategyMode \u00b6 A class of Strategy Modes StrategyType \u00b6 A class of Strategy Type TradingReportType \u00b6 A class of Trading Report Types TradingType \u00b6 A class of Trading Types instrument special \u00b6 instrument \u00b6 Instrument Class Instrument \u00b6 Instrument Class __init__ ( self , segment , tradingsymbol , broker_token , tick_size , lot_size , expiry = None , strike_price = None ) special \u00b6 Init method that is used while creating an object of this class Parameters: Name Type Description Default segment segment required tradingsymbol trading symbol required broker_token alphnumeric token required tick_size tick size required lot_size lot size required expiry expiry date None strike_price strike amount / value None Source code in pyalgotrading/instrument/instrument.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def __init__ ( self , segment , tradingsymbol , broker_token , tick_size , lot_size , expiry = None , strike_price = None ): \"\"\" Init method that is used while creating an object of this class Args: segment: segment tradingsymbol: trading symbol broker_token: alphnumeric token tick_size: tick size lot_size: lot size expiry: expiry date strike_price: strike amount / value \"\"\" self . segment = segment self . exchange = self . segment . exchange self . tradingsymbol = tradingsymbol self . broker_token = broker_token self . tick_size = tick_size self . lot_size = lot_size self . expiry = expiry self . strike_price = strike_price is_expired ( self ) \u00b6 Returns whether expired or not Returns: Type Description True or False Source code in pyalgotrading/instrument/instrument.py 40 41 42 43 44 45 46 47 48 49 def is_expired ( self ): \"\"\" Returns whether expired or not Returns: True or False \"\"\" if self . expiry : return date . today () > self . expiry else : return False will_expire ( self ) \u00b6 Returns expiry details Returns: Type Description a value containing the expiry date Source code in pyalgotrading/instrument/instrument.py 32 33 34 35 36 37 38 def will_expire ( self ): \"\"\" Returns expiry details Returns: a value containing the expiry date \"\"\" return self . expiry order special \u00b6 order_base \u00b6 OrderBase \u00b6 Base class for Regular Order / Bracket Order cancel_order ( self ) \u00b6 This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Source code in pyalgotrading/order/order_base.py 32 33 34 35 36 37 38 39 def cancel_order ( self ): \"\"\" This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Returns: \"\"\" # This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. pass exit_position ( self ) \u00b6 This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Source code in pyalgotrading/order/order_base.py 23 24 25 26 27 28 29 30 def exit_position ( self ): \"\"\" This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Returns: \"\"\" # This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. pass get_order_status ( self ) \u00b6 This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Source code in pyalgotrading/order/order_base.py 14 15 16 17 18 19 20 21 def get_order_status ( self ): \"\"\" This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Returns: \"\"\" # This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. pass place_order ( self ) \u00b6 This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Source code in pyalgotrading/order/order_base.py 5 6 7 8 9 10 11 12 def place_order ( self ): \"\"\" This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Returns: \"\"\" # This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. pass order_bracket_base \u00b6 Class for Bracket Order BuyOrderBracket \u00b6 Class for Bracket Order Buy __init__ ( self , instrument , order_code , order_variety , quantity , price = None , trigger_price = None , stoploss_trigger = None , target_trigger = None , trailing_stoploss_trigger = None ) special \u00b6 Init method that is used while creating an object of this class Source code in pyalgotrading/order/order_bracket_base.py 53 54 55 56 57 58 def __init__ ( self , instrument , order_code , order_variety , quantity , price = None , trigger_price = None , stoploss_trigger = None , target_trigger = None , trailing_stoploss_trigger = None ): \"\"\" Init method that is used while creating an object of this class \"\"\" super () . __init__ ( instrument = instrument , order_transaction_type = BrokerOrderTransactionTypeConstants . BROKER_ORDER_TRANSACTION_TYPE_BUY , order_code = order_code , order_variety = order_variety , quantity = quantity , price = price , trigger_price = trigger_price , stoploss_trigger = stoploss_trigger , target_trigger = target_trigger , trailing_stoploss_trigger = trailing_stoploss_trigger ) OrderBracketBase \u00b6 Class for Bracket Order __init__ ( self , instrument , order_transaction_type , order_code , order_variety , quantity , price = None , trigger_price = None , stoploss_trigger = None , target_trigger = None , trailing_stoploss_trigger = None ) special \u00b6 Init method that is used while creating an object of this class Parameters: Name Type Description Default instrument instrument key required order_transaction_type order transaction type required order_code bracket order required order_variety market / limit / stoploss market / stoploss limit required quantity order quantity required price amount / value None trigger_price trigger amount / value None stoploss_trigger stoploss trigger amount / value None target_trigger target trigger amount / value None trailing_stoploss_trigger trailing stoploss trigger amount / value None Source code in pyalgotrading/order/order_bracket_base.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def __init__ ( self , instrument , order_transaction_type , order_code , order_variety , quantity , price = None , trigger_price = None , stoploss_trigger = None , target_trigger = None , trailing_stoploss_trigger = None ): \"\"\" Init method that is used while creating an object of this class Args: instrument: instrument key order_transaction_type: order transaction type order_code: bracket order order_variety: market / limit / stoploss market / stoploss limit quantity: order quantity price: amount / value trigger_price: trigger amount / value stoploss_trigger: stoploss trigger amount / value target_trigger: target trigger amount / value trailing_stoploss_trigger: trailing stoploss trigger amount / value \"\"\" self . instrument = instrument self . order_transaction_type = order_transaction_type self . order_type = BrokerOrderTypeConstants . BROKER_ORDER_TYPE_BRACKET self . order_code = order_code self . order_variety = order_variety self . quantity = quantity self . price = price self . trigger_price = trigger_price self . target_trigger = target_trigger self . stoploss_trigger = stoploss_trigger self . trailing_stoploss_trigger = trailing_stoploss_trigger is_closed ( self ) \u00b6 This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Returns: Type Description True / False Source code in pyalgotrading/order/order_bracket_base.py 39 40 41 42 43 44 45 46 def is_closed ( self ): \"\"\" This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Returns: True / False \"\"\" # This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. pass SellOrderBracket \u00b6 Class for Bracket Order Sell __init__ ( self , instrument , order_code , order_variety , quantity , price = None , trigger_price = None , stoploss_trigger = None , target_trigger = None , trailing_stoploss_trigger = None ) special \u00b6 Init method that is used while creating an object of this class Source code in pyalgotrading/order/order_bracket_base.py 65 66 67 68 69 70 def __init__ ( self , instrument , order_code , order_variety , quantity , price = None , trigger_price = None , stoploss_trigger = None , target_trigger = None , trailing_stoploss_trigger = None ): \"\"\" Init method that is used while creating an object of this class \"\"\" super () . __init__ ( instrument = instrument , order_transaction_type = BrokerOrderTransactionTypeConstants . BROKER_ORDER_TRANSACTION_TYPE_SELL , order_code = order_code , order_variety = order_variety , quantity = quantity , price = price , trigger_price = trigger_price , stoploss_trigger = stoploss_trigger , target_trigger = target_trigger , trailing_stoploss_trigger = trailing_stoploss_trigger ) order_regular_base \u00b6 Class for Regular Order BuyOrderRegular \u00b6 Class for Regular Order Buy __init__ ( self , instrument , order_code , order_variety , quantity , price = None , trigger_price = None ) special \u00b6 Init method that is used while creating an object of this class Source code in pyalgotrading/order/order_regular_base.py 38 39 40 41 42 43 def __init__ ( self , instrument , order_code , order_variety , quantity , price = None , trigger_price = None ): \"\"\" Init method that is used while creating an object of this class \"\"\" super () . __init__ ( instrument = instrument , order_transaction_type = BrokerOrderTransactionTypeConstants . BROKER_ORDER_TRANSACTION_TYPE_BUY , order_code = order_code , order_variety = order_variety , quantity = quantity , price = price , trigger_price = trigger_price ) OrderRegularBase \u00b6 Class for Regular Order __init__ ( self , instrument , order_transaction_type , order_code , order_variety , quantity , price = None , trigger_price = None ) special \u00b6 Init method that is used while creating an object of this class Parameters: Name Type Description Default instrument instrument key required order_transaction_type order transaction type required order_code regular order required order_variety market / limit / stoploss market / stoploss limit required quantity order quantity required price amount / value None trigger_price trigger amount / value None Source code in pyalgotrading/order/order_regular_base.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 def __init__ ( self , instrument , order_transaction_type , order_code , order_variety , quantity , price = None , trigger_price = None ): \"\"\" Init method that is used while creating an object of this class Args: instrument: instrument key order_transaction_type: order transaction type order_code: regular order order_variety: market / limit / stoploss market / stoploss limit quantity: order quantity price: amount / value trigger_price: trigger amount / value \"\"\" self . instrument = instrument self . order_transaction_type = order_transaction_type self . order_type = BrokerOrderTypeConstants . BROKER_ORDER_TYPE_REGULAR self . order_code = order_code self . order_variety = order_variety self . quantity = quantity self . price = price self . trigger_price = trigger_price SellOrderRegular \u00b6 Class for Regular Order Buy __init__ ( self , instrument , order_code , order_variety , quantity , price = None , trigger_price = None ) special \u00b6 Init method that is used while creating an object of this class Source code in pyalgotrading/order/order_regular_base.py 50 51 52 53 54 55 def __init__ ( self , instrument , order_code , order_variety , quantity , price = None , trigger_price = None ): \"\"\" Init method that is used while creating an object of this class \"\"\" super () . __init__ ( instrument = instrument , order_transaction_type = BrokerOrderTransactionTypeConstants . BROKER_ORDER_TRANSACTION_TYPE_SELL , order_code = order_code , order_variety = order_variety , quantity = quantity , price = price , trigger_price = trigger_price ) strategy special \u00b6 strategy_base \u00b6 StrategyBase \u00b6 Dummy placeholder class. Here to ensure all required methods are implemented and as per requirements. Once uploaded, this strategy will be replaced with the real base class strategy __init__ ( self , * args , ** kwargs ) special \u00b6 Init method that is used while creating an object of this class Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Source code in pyalgotrading/strategy/strategy_base.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def __init__ ( self , * args , ** kwargs ): \"\"\" Init method that is used while creating an object of this class Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list \"\"\" # Dummy attributes self . strategy_parameters = defaultdict ( lambda : 'dummy' ) self . broker = broker . broker_connection_base . BrokerConnectionBase () self . utils = broker . utils # Dummy Order Attributes self . BuyOrderRegular = BuyOrderRegular self . SellOrderRegular = SellOrderRegular self . BuyOrderBracket = BuyOrderBracket self . SellOrderBracket = SellOrderBracket # Dummy strategy config attributes self . strategy_mode = StrategyMode . INTRADAY # <Type: Enum of type StrategyMode; This attribute will hold one of the following values - StrategyMode.INTRADAY or StrategyMode.DELIVERY. This value is passed to pyalgotrading.algobulls.connection.backtest/papertest/realtrade methods.> self . number_of_lots = 1 # <Type: This attribute will hold one of the following values - StrategyMode.INTRADAY or StrategyMode.DELIVERY. This value is passed to pyalgotrading.algobulls.connection.backtest/papertest/realtrade methods.> get_historical_data ( self , instrument ) \u00b6 Fetch the historical data of an instrument This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Parameters: Name Type Description Default instrument instrument key required Returns: Type Description None Source code in pyalgotrading/strategy/strategy_base.py 52 53 54 55 56 57 58 59 60 61 62 63 def get_historical_data ( self , instrument ): \"\"\" Fetch the historical data of an instrument This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Args: instrument: instrument key Returns: None \"\"\" # This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. pass initialize ( self ) \u00b6 Initialization task for this strategy. Calling this method should initialise/reset the strategy's internal state variables to original state. Every Strategy should initialize its internal state variables in this task to reset values. Indented to be called by TLS as part of pre market activity & for backtesting mode, at the start of every new backtesting day. Source code in pyalgotrading/strategy/strategy_base.py 74 75 76 77 78 79 80 81 82 83 @abstractmethod def initialize ( self ): \"\"\" Initialization task for this strategy. Calling this method should initialise/reset the strategy's internal state variables to original state. Every Strategy should initialize its internal state variables in this task to reset values. Indented to be called by TLS as part of pre market activity & for backtesting mode, at the start of every new backtesting day. \"\"\" raise NotImplementedError name () staticmethod \u00b6 Name of the strategy Returns: None Source code in pyalgotrading/strategy/strategy_base.py 42 43 44 45 46 47 48 49 50 @staticmethod @abstractmethod def name (): \"\"\" Name of the strategy Returns: None \"\"\" raise NotImplementedError strategy_enter_position ( self , candle , instrument , sideband_info ) \u00b6 Enter position for each instrument Parameters: Name Type Description Default candle the current candle required instrument the instrument key required sideband_info the additional information regarding the instrument action required Returns: Type Description the order, if position is entered Source code in pyalgotrading/strategy/strategy_base.py 97 98 99 100 101 102 103 104 105 106 107 108 109 @abstractmethod def strategy_enter_position ( self , candle , instrument , sideband_info ): \"\"\" Enter position for each instrument Args: candle: the current candle instrument: the instrument key sideband_info: the additional information regarding the instrument action Returns: the order, if position is entered \"\"\" raise NotImplementedError strategy_exit_position ( self , candle , instrument , sideband_info ) \u00b6 Exit position for each instrument Parameters: Name Type Description Default candle the current candle required instrument the instrument key required sideband_info the additional information regarding the instrument action required Returns: Type Description True if order is exited else False Source code in pyalgotrading/strategy/strategy_base.py 124 125 126 127 128 129 130 131 132 133 134 135 136 @abstractmethod def strategy_exit_position ( self , candle , instrument , sideband_info ): \"\"\" Exit position for each instrument Args: candle: the current candle instrument: the instrument key sideband_info: the additional information regarding the instrument action Returns: True if order is exited else False \"\"\" raise NotImplementedError strategy_select_instruments_for_entry ( self , candle , instruments_bucket ) \u00b6 Select instruments for entry here Parameters: Name Type Description Default candle the current candle required instruments_bucket the list of instruments to be selected from required Returns: Type Description selected instruments and sideband (additional) information for each Source code in pyalgotrading/strategy/strategy_base.py 85 86 87 88 89 90 91 92 93 94 95 def strategy_select_instruments_for_entry ( self , candle , instruments_bucket ): \"\"\" Select instruments for entry here Args: candle: the current candle instruments_bucket: the list of instruments to be selected from Returns: selected instruments and sideband (additional) information for each \"\"\" raise NotImplementedError strategy_select_instruments_for_exit ( self , candle , instruments_bucket ) \u00b6 Select instruments for exit here Parameters: Name Type Description Default candle the current candle required instruments_bucket the list of instruments to be selected from required Returns: Type Description selected instruments and sideband (additional) information for each Source code in pyalgotrading/strategy/strategy_base.py 111 112 113 114 115 116 117 118 119 120 121 122 @abstractmethod def strategy_select_instruments_for_exit ( self , candle , instruments_bucket ): \"\"\" Select instruments for exit here Args: candle: the current candle instruments_bucket: the list of instruments to be selected from Returns: selected instruments and sideband (additional) information for each \"\"\" raise NotImplementedError versions_supported () staticmethod \u00b6 Version of the AlgoBulls platform that this Strategy will run on/tested on :return: Should return a single version or list of versions of ABC on which the current strategy has been tested to run successfully Source code in pyalgotrading/strategy/strategy_base.py 65 66 67 68 69 70 71 72 @staticmethod @abstractmethod def versions_supported (): \"\"\" Version of the AlgoBulls platform that this Strategy will run on/tested on :return: Should return a single version or list of versions of ABC on which the current strategy has been tested to run successfully \"\"\" raise NotImplementedError validate_strategy \u00b6 A module in construction. Create class which validates the strategy - 1. Ensures all methods are implemented and all looks good 2. Basic sanity checks Add additional information - 1. Add a versioning information in the class automatically utils special \u00b6 candlesticks special \u00b6 Handy functions for computing various candlesticks patterns from OHLC data heikinashi \u00b6 HeikinAshi ( japanese_data , ohlc = ( 'timestamp' , 'open' , 'high' , 'low' , 'close' )) \u00b6 Computes HeikinAshi Candlesticks Pattern data from Japanese candlesticks pattern data. Parameters: Name Type Description Default japanese_data DataFrame Pandas DataFrame holding Japanese Candlesticks Pattern Data required ohlc tuple Column names corresponding to 'timestamp', 'open', 'high', 'low' and 'close' data respectively ('timestamp', 'open', 'high', 'low', 'close') Returns: Type Description HeikinAshi Candlesticks Pattern data Source code in pyalgotrading/utils/candlesticks/heikinashi.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def HeikinAshi ( japanese_data : pd . DataFrame , ohlc : tuple = ( 'timestamp' , 'open' , 'high' , 'low' , 'close' )): \"\"\" Computes HeikinAshi Candlesticks Pattern data from Japanese candlesticks pattern data. Args: japanese_data: Pandas DataFrame holding Japanese Candlesticks Pattern Data ohlc: Column names corresponding to 'timestamp', 'open', 'high', 'low' and 'close' data respectively Returns: HeikinAshi Candlesticks Pattern data \"\"\" if not len ( ohlc ) >= 5 : print ( \"Argument 'ohlc' should be a tuple of 5 values corresponding to the column names in 'japanese_data' pandas DataFrame, for 'timestamp', 'open', 'high', 'low' and 'close' data respectively.\" ) ha_open = 'ha_' + ohlc [ 0 ] ha_high = 'ha_' + ohlc [ 1 ] ha_low = 'ha_' + ohlc [ 2 ] ha_close = 'ha_' + ohlc [ 3 ] japanese_data = japanese_data . copy () # make sure we don't modify the original DataFrame japanese_data [ ha_close ] = ( japanese_data [ ohlc [ 1 ]] + japanese_data [ ohlc [ 2 ]] + japanese_data [ ohlc [ 3 ]] + japanese_data [ ohlc [ 4 ]]) / 4 japanese_data [ ha_open ] = 0.0 for i in range ( 0 , len ( japanese_data )): if i == 0 : japanese_data [ ha_open ] . iat [ i ] = ( japanese_data [ ohlc [ 1 ]] . iat [ i ] + japanese_data [ ohlc [ 4 ]] . iat [ i ]) / 2 else : japanese_data [ ha_open ] . iat [ i ] = ( japanese_data [ ha_open ] . iat [ i - 1 ] + japanese_data [ ha_close ] . iat [ i - 1 ]) / 2 japanese_data [ ha_high ] = japanese_data [[ ha_open , ha_close , ohlc [ 2 ]]] . max ( axis = 1 ) japanese_data [ ha_low ] = japanese_data [[ ha_open , ha_close , ohlc [ 3 ]]] . min ( axis = 1 ) # Create separate DataFrame with the required columns only heikinashi_data = pd . DataFrame () heikinashi_data [ 'timestamp' ] = japanese_data [ 'timestamp' ] heikinashi_data [ 'open' ] = japanese_data [ ha_open ] heikinashi_data [ 'high' ] = japanese_data [ ha_high ] heikinashi_data [ 'low' ] = japanese_data [ ha_low ] heikinashi_data [ 'close' ] = japanese_data [ ha_close ] return heikinashi_data linebreak \u00b6 Linebreak ( japanese_candles ) \u00b6 Parameters: Name Type Description Default japanese_candles required Source code in pyalgotrading/utils/candlesticks/linebreak.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def Linebreak ( japanese_candles ): \"\"\" Args: japanese_candles: Returns: \"\"\" linebreak_candles = [{ 'close' : candle [ 'close' ], 'open' : candle [ 'open' ], 'timestamp' : candle [ 'timestamp' ]} for _ , candle in japanese_candles . iloc [: 3 ] . iterrows ()] for _ , candle in japanese_candles . iloc [ 3 :] . iterrows (): all_greater = all ( candle [ 'close' ] > _ for _ in [ max ( _linebreakcandle [ 'open' ], _linebreakcandle [ 'close' ]) for _linebreakcandle in linebreak_candles [ - 3 :]]) all_lesser = all ( candle [ 'close' ] < _ for _ in [ min ( _linebreakcandle [ 'open' ], _linebreakcandle [ 'close' ]) for _linebreakcandle in linebreak_candles [ - 3 :]]) prev_linebreak_candle = linebreak_candles [ - 1 ] if all_greater : new_linebreak_candle = { 'open' : max ( prev_linebreak_candle [ 'open' ], prev_linebreak_candle [ 'close' ]), 'close' : candle [ 'close' ], 'timestamp' : candle [ 'timestamp' ]} linebreak_candles . append ( new_linebreak_candle ) elif all_lesser : new_linebreak_candle = { 'open' : min ( prev_linebreak_candle [ 'open' ], prev_linebreak_candle [ 'close' ]), 'close' : candle [ 'close' ], 'timestamp' : candle [ 'timestamp' ]} linebreak_candles . append ( new_linebreak_candle ) return pd . DataFrame ( linebreak_candles ) renko \u00b6 Renko ( japanese_candles , brick_count = 2 , initial_open = None , initial_close = None ) \u00b6 Parameters: Name Type Description Default japanese_candles required brick_count 2 initial_open None initial_close None Source code in pyalgotrading/utils/candlesticks/renko.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def Renko ( japanese_candles , brick_count = 2 , initial_open = None , initial_close = None ): \"\"\" Args: japanese_candles: brick_count: initial_open: initial_close: Returns: \"\"\" if not initial_close : initial_open = japanese_candles . iloc [ 0 ][ 'open' ] initial_close = japanese_candles . iloc [ 0 ][ 'close' ] else : initial_open = japanese_candles . iloc [ 0 ][ 'open' ] + ( brick_count - (( japanese_candles . iloc [ 0 ][ 'open' ] - initial_open ) % brick_count )) initial_close = japanese_candles . iloc [ 0 ][ 'close' ] + ( brick_count - (( japanese_candles . iloc [ 0 ][ 'close' ] - initial_close ) % brick_count )) renko_candles = [{ 'timestamp' : japanese_candles . iloc [ 0 ][ 'timestamp' ], 'open' : initial_open , 'close' : initial_close }] prev_renko_candle = renko_candles [ - 1 ] for _ , candle in japanese_candles . iloc [ 1 :] . iterrows (): max_open_close = max ( prev_renko_candle [ 'open' ], prev_renko_candle [ 'close' ]) min_open_close = min ( prev_renko_candle [ 'open' ], prev_renko_candle [ 'close' ]) if candle [ 'close' ] > max_open_close : number_of_renko_candles = math . floor (( candle [ 'close' ] - max_open_close ) / brick_count ) for i in range ( number_of_renko_candles ): renko_candles . append ({ 'timestamp' : candle [ 'timestamp' ], 'open' : max_open_close , 'close' : max_open_close + brick_count }) prev_renko_candle = renko_candles [ - 1 ] max_open_close = max ( prev_renko_candle [ 'open' ], prev_renko_candle [ 'close' ]) elif candle [ 'close' ] < min_open_close : number_of_renko_candles = math . floor (( min_open_close - candle [ 'close' ]) / brick_count ) for i in range ( number_of_renko_candles ): renko_candles . append ({ 'timestamp' : candle [ 'timestamp' ], 'open' : min_open_close , 'close' : min_open_close - brick_count }) prev_renko_candle = renko_candles [ - 1 ] min_open_close = min ( prev_renko_candle [ 'open' ], prev_renko_candle [ 'close' ]) return pd . DataFrame ( renko_candles ) func \u00b6 A module for plotting candlesticks import_with_install ( package_import_name , package_install_name = None , package_version = '' ) \u00b6 Helps import 'package' even if its not installed. If package is installed, it will be imported and returned. If its not installed, it will be installed using 'pip' and a re-import will be attempted, which should succeed if the package was imported correctly. Parameters: Name Type Description Default package_import_name name of package to be installed using pip, str required package_install_name name of package to be imported. Default is None, which means package can be imported with the same name as used for installation. If not, this parameter can be used to specify a different import name. None package_version version of package to be installed, str, Example: '1.0.0' or '==1.0.0' '' Returns: Type Description The imported package Source code in pyalgotrading/utils/func.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def import_with_install ( package_import_name , package_install_name = None , package_version = '' ): \"\"\" Helps import 'package' even if its not installed. If package is installed, it will be imported and returned. If its not installed, it will be installed using 'pip' and a re-import will be attempted, which should succeed if the package was imported correctly. Args: package_import_name: name of package to be installed using pip, str package_install_name: name of package to be imported. Default is None, which means package can be imported with the same name as used for installation. If not, this parameter can be used to specify a different import name. package_version: version of package to be installed, str, Example: '1.0.0' or '==1.0.0' Returns: The imported package \"\"\" package_install_name = package_install_name if package_install_name is not None else package_import_name package_version = f '== { package_version } ' if (( package_version != '' ) and ( '==' not in package_version )) else package_version try : return __import__ ( package_import_name ) except ImportError : print ( f \"Installing package { package_import_name } via pip...\" ) import subprocess import sys subprocess . check_call ([ sys . executable , '-m' , 'pip' , 'install' , package_install_name , package_version ]) return __import__ ( package_import_name ) plot_candlestick_chart ( data , plot_type , caption = '' , hide_missing_dates = False , show = True , indicators = (), plot_indicators_separately = False , plot_height = 500 , plot_width = 1000 ) \u00b6 Function to create charts for various candlesticks pattern data - - Japanese - Heikin-Ashi - Linebreak - Renko - Japanese for Quandl data Support for displaying indicator data (on top of candlesticks pattern data or separately). Parameters: Name Type Description Default data DataFrame Pandas DataFrame with columns timestamp , open , 'high , 'low , close required plot_type PlotType Enum of type PlotType required caption str Caption for the chart '' hide_missing_dates bool If True, missing dates in the data (say due to no data over weekend) will be hidden and a continuous plot will be shown. If False, gaps would be shown for missing dates. However, the date formatting on the x-axis is better here, so prefer this when there are no date gaps. False show bool If True, figure will be shown. Useful for displaying figures inline while using Jupyter Notebooks True indicators tuple Indicator data to be displayed () plot_indicators_separately bool If True, indicator data would be plotted in a different subplot. Use this when indicator data range coincides with the historical data range. If False, it will be plotted in the same subplot as the historical data. Use this when indicator data range does not coincide with the historical data range False plot_height int Plot height in pixels 500 plot_width int Plot width in pixels 1000 Source code in pyalgotrading/utils/func.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 def plot_candlestick_chart ( data : pd . DataFrame , plot_type : PlotType , caption : str = '' , hide_missing_dates : bool = False , show : bool = True , indicators : tuple = (), plot_indicators_separately : bool = False , plot_height : int = 500 , plot_width : int = 1000 ): \"\"\" Function to create charts for various candlesticks pattern data - - Japanese - Heikin-Ashi - Linebreak - Renko - Japanese for Quandl data Support for displaying indicator data (on top of candlesticks pattern data or separately). Args: data: Pandas DataFrame with columns `timestamp`, `open`, 'high`, 'low`, `close` plot_type: Enum of type PlotType caption: Caption for the chart hide_missing_dates: If True, missing dates in the `data` (say due to no data over weekend) will be hidden and a continuous plot will be shown. If False, gaps would be shown for missing dates. However, the date formatting on the x-axis is better here, so prefer this when there are no date gaps. show: If True, figure will be shown. Useful for displaying figures inline while using Jupyter Notebooks indicators: Indicator data to be displayed plot_indicators_separately: If True, indicator data would be plotted in a different subplot. Use this when indicator data range coincides with the historical data range. If False, it will be plotted in the same subplot as the historical data. Use this when indicator data range does not coincide with the historical data range plot_height: Plot height in pixels plot_width: Plot width in pixels \"\"\" import_with_install ( package_import_name = 'plotly' , package_install_name = 'plotly' , package_version = '4.7.1' ) from plotly.subplots import make_subplots from plotly import graph_objects as go # Sanity checks if not isinstance ( plot_type , PlotType ): print ( f 'Error: plot_type should be an instance of { PlotType . __class__ } ' ) return # Plot if plot_type is PlotType . QUANDL_JAPANESE : data [ 'timestamp' ] = data . index if hide_missing_dates : # Plotly has a limitation where if the timestamp are DateTime.DateTime objects which are not continuous, # it will plot the missing dates as empty space, which makes the curve look unnatural. The below code gives # custom timestamp formatting, which will be the x-axis ticks format_timestamp = lambda x : x . strftime ( \" %d /%m %H:%M\" ) timestamps = data [ 'timestamp' ] . apply ( format_timestamp ) else : timestamps = data [ 'timestamp' ] candlesticks_data_subplot_row_index = 1 candlesticks_data_subplot_col_index = 1 if indicators and ( plot_indicators_separately is True ): fig = make_subplots ( rows = 3 , cols = 1 , vertical_spacing = 0.05 , shared_xaxes = True , specs = [[{ \"rowspan\" : 2 }], [{}], [{}]]) indicator_subplot_row_index = 3 indicator_subplot_col_index = 1 else : fig = make_subplots ( rows = 1 , cols = 1 , vertical_spacing = 0.05 , shared_xaxes = True ) indicator_subplot_row_index = 1 indicator_subplot_col_index = 1 if plot_type in [ PlotType . JAPANESE , PlotType . HEIKINASHI ]: fig . append_trace ( go . Candlestick ( x = timestamps , open = data [ 'open' ], high = data [ 'high' ], low = data [ 'low' ], close = data [ 'close' ], name = 'Historical Data' ), row = candlesticks_data_subplot_row_index , col = candlesticks_data_subplot_col_index ) elif plot_type == PlotType . LINEBREAK : fig = go . Figure ( data = [ go . Candlestick ( x = timestamps , open = data [ 'open' ], high = data [[ \"open\" , \"close\" ]] . max ( axis = 1 ), low = data [[ \"open\" , \"close\" ]] . min ( axis = 1 ), close = data [ 'close' ], name = 'Historical Data' )]) elif plot_type == PlotType . RENKO : fig = go . Figure ( data = [ go . Candlestick ( x = timestamps , open = data [ 'open' ], high = data [[ \"open\" , \"close\" ]] . max ( axis = 1 ), low = data [[ \"open\" , \"close\" ]] . min ( axis = 1 ), close = data [ 'close' ], name = 'Historical Data' )]) elif plot_type == PlotType . QUANDL_JAPANESE : fig = go . Figure ( data = [ go . Candlestick ( x = timestamps , open = data [ 'Open' ], high = data [ 'High' ], low = data [ 'Low' ], close = data [ 'Close' ], name = 'Historical Data' )]) else : print ( f 'Error: plot_type ( { plot_type } ) is not implemented yet' ) return for indicator in indicators : indicator_name = indicator [ 'name' ] indicator_data = indicator [ 'data' ] extra = indicator [ 'extra' ] if 'extra' in indicator else {} fig . add_trace ( go . Scatter ( x = timestamps , y = indicator_data , name = indicator_name , ** extra ), row = indicator_subplot_row_index , col = indicator_subplot_col_index ) # Plot customization if hide_missing_dates : # Plotly has a limitation where if the timestamp are DateTime.DateTime objects which are not continuous, # it will plot the missing dates as empty space, which makes the curve look unnatural. Hence, the below fix fig . layout . xaxis . type = 'category' fig . update ( layout_xaxis_rangeslider_visible = False ) fig . update_layout ( title = { 'text' : caption , 'y' : 0.9 , 'x' : 0.5 , 'xanchor' : 'center' , 'yanchor' : 'bottom' }, height = plot_height , width = plot_width ) # Show the plot if show : fig . show () global counter fig . write_image ( f 'fig_ { counter } .pdf' ) counter += 1","title":"pyalgotrading"},{"location":"package_pyalgotrading/#pyalgotrading","text":"Official Python Package for Algorithmic Trading APIs powered by AlgoBulls. Links: GitHub | AlgoBulls","title":"pyalgotrading"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls","text":"Package for interacting with the AlgoBulls backend","title":"algobulls"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.api","text":"Module for handling API calls to the AlgoBulls backend.","title":"api"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.api.AlgoBullsAPI","text":"AlgoBulls API","title":"AlgoBullsAPI"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.api.AlgoBullsAPI.__init__","text":"Init method that is used while creating an object of this class Source code in pyalgotrading/algobulls/api.py 20 21 22 23 24 def __init__ ( self ): \"\"\" Init method that is used while creating an object of this class \"\"\" self . headers = None","title":"__init__()"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.api.AlgoBullsAPI.create_strategy","text":"Create a new strategy for the user on the AlgoBulls platform. Parameters: Name Type Description Default strategy_name str name of the strategy required strategy_details str Python code of the strategy required abc_version str value of one of the enums available under AlgoBullsEngineVersion required Returns: Type Description dict JSON Response received from AlgoBulls platform after (attempt to) creating a new strategy. Warning For every user, the strategy_name should be unique. You cannot create multiple strategies with the same name. ENDPOINT POST v2/user/strategy/build/python Source code in pyalgotrading/algobulls/api.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def create_strategy ( self , strategy_name : str , strategy_details : str , abc_version : str ) -> dict : \"\"\" Create a new strategy for the user on the AlgoBulls platform. Args: strategy_name: name of the strategy strategy_details: Python code of the strategy abc_version: value of one of the enums available under [AlgoBullsEngineVersion]() Returns: JSON Response received from AlgoBulls platform after (attempt to) creating a new strategy. Warning: For every user, the `strategy_name` should be unique. You cannot create multiple strategies with the same name. Info: ENDPOINT `POST` v2/user/strategy/build/python \"\"\" json_data = { 'strategyName' : strategy_name , 'strategyDetails' : strategy_details , 'abcVersion' : abc_version } endpoint = f 'v2/user/strategy/build/python' response = self . _send_request ( endpoint = endpoint , method = 'post' , json_data = json_data ) return response","title":"create_strategy()"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.api.AlgoBullsAPI.get_all_strategies","text":"Get all the Python strategies created by the user on the AlgoBulls platform Returns: Type Description dict JSON Response received from AlgoBulls platform with list of all the created strategies. ENDPOINT OPTIONS v2/user/strategy/build/python Source code in pyalgotrading/algobulls/api.py 119 120 121 122 123 124 125 126 127 128 129 130 131 def get_all_strategies ( self ) -> dict : \"\"\" Get all the Python strategies created by the user on the AlgoBulls platform Returns: JSON Response received from AlgoBulls platform with list of all the created strategies. Info: ENDPOINT `OPTIONS` v2/user/strategy/build/python \"\"\" endpoint = f 'v2/user/strategy/build/python' response = self . _send_request ( endpoint = endpoint , method = 'options' ) return response","title":"get_all_strategies()"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.api.AlgoBullsAPI.get_job_status","text":"Get status for a BACKTESTING/PAPERTESTING/REALTRADING Job Parameters: Name Type Description Default strategy_code str Strategy code required trading_type str Trading type required broker str Name of the broker '' Returns: Type Description dict Job status ENDPOINT GET v1/customer_strategy_algotrading Source code in pyalgotrading/algobulls/api.py 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 def get_job_status ( self , strategy_code : str , trading_type : str , broker : str = '' ) -> dict : \"\"\" Get status for a BACKTESTING/PAPERTESTING/REALTRADING Job Args: strategy_code: Strategy code trading_type: Trading type broker: Name of the broker Returns: Job status Info: ENDPOINT `GET` v1/customer_strategy_algotrading \"\"\" params = { 'strategyCode' : strategy_code , 'strategyType' : StrategyType . PYTHON . value , 'tradingType' : trading_type . value , 'broker' : broker } endpoint = f 'v1/customer_strategy_algotrading' response = self . _send_request ( endpoint = endpoint , params = params ) return response","title":"get_job_status()"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.api.AlgoBullsAPI.get_reports","text":"Get reports for a BACKTESTING/PAPERTESTING/REALTRADING Job Parameters: Name Type Description Default strategy_code str Strategy code required trading_type str Value of TradingType Enum required report_type str Value of TradingReportType Enum required broker str Name of the broker '' Returns: Type Description dict Report data ENDPOINT GET v1/customer_strategy_algotrading_reports Source code in pyalgotrading/algobulls/api.py 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 def get_reports ( self , strategy_code : str , trading_type : str , report_type : str , broker : str = '' ) -> dict : \"\"\" Get reports for a BACKTESTING/PAPERTESTING/REALTRADING Job Args: strategy_code: Strategy code trading_type: Value of TradingType Enum report_type: Value of TradingReportType Enum broker: Name of the broker Returns: Report data Info: ENDPOINT `GET` v1/customer_strategy_algotrading_reports \"\"\" params = { 'strategyCode' : strategy_code , 'strategyType' : StrategyType . PYTHON . value , 'tradingType' : trading_type . value , 'reportType' : report_type . value , 'broker' : broker } endpoint = f 'v1/customer_strategy_algotrading_reports' response = self . _send_request ( endpoint = endpoint , params = params ) return response","title":"get_reports()"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.api.AlgoBullsAPI.get_strategy_details","text":"Get strategy details for Parameters: Name Type Description Default strategy_code str unique code of strategy, which is received while creating the strategy or required Returns: Type Description dict JSON ENDPOINT GET v2/user/strategy/build/python Source code in pyalgotrading/algobulls/api.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 def get_strategy_details ( self , strategy_code : str ) -> dict : \"\"\" Get strategy details for Arguments: strategy_code: unique code of strategy, which is received while creating the strategy or Return: JSON Info: ENDPOINT `GET` v2/user/strategy/build/python \"\"\" params = { 'strategyCode' : strategy_code } endpoint = f 'v2/user/strategy/build/python' response = self . _send_request ( endpoint = endpoint , params = params ) return response","title":"get_strategy_details()"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.api.AlgoBullsAPI.search_instrument","text":"Parameters: Name Type Description Default instrument str instrument key required Returns: Type Description dict JSON Response ENDPOINT GET v2/instrument/search Source code in pyalgotrading/algobulls/api.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 def search_instrument ( self , instrument : str ) -> dict : \"\"\" Args: instrument: instrument key Returns: JSON Response Info: ENDPOINT `GET` v2/instrument/search \"\"\" params = { 'instrument' : instrument } endpoint = f 'v2/instrument/search' response = self . _send_request ( endpoint = endpoint , params = params , requires_authorization = False ) return response","title":"search_instrument()"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.api.AlgoBullsAPI.set_access_token","text":"Sets access token to the header attribute, which is needed for APIs requiring authorization Package for interacting with AlgoBulls Algorithmic Trading Platform (https://www.algobulls.com) Parameters: Name Type Description Default access_token str Access token generated by logging to the URL given by the get_authorization_url() method required Source code in pyalgotrading/algobulls/api.py 26 27 28 29 30 31 32 33 34 35 36 def set_access_token ( self , access_token : str ): \"\"\" Sets access token to the header attribute, which is needed for APIs requiring authorization Package for interacting with AlgoBulls Algorithmic Trading Platform (https://www.algobulls.com) Args: access_token: Access token generated by logging to the URL given by the `get_authorization_url()` method \"\"\" self . headers = { 'Authorization' : f ' { access_token } ' }","title":"set_access_token()"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.api.AlgoBullsAPI.set_strategy_config","text":"Parameters: Name Type Description Default strategy_code str strategy code required strategy_config str strategy configuration required Returns: Type Description dict Info: ENDPOINT PATCH v1/customer_strategy_tweak Source code in pyalgotrading/algobulls/api.py 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 def set_strategy_config ( self , strategy_code : str , strategy_config : str ) -> dict : \"\"\" Args: strategy_code: strategy code strategy_config: strategy configuration Returns: Info: ENDPOINT PATCH v1/customer_strategy_tweak \"\"\" params = { 'strategyCode' : strategy_code , 'strategyType' : StrategyType . PYTHON . value } json_data = strategy_config endpoint = f 'v1/customer_strategy_tweak' response = self . _send_request ( method = 'patch' , endpoint = endpoint , params = params , json_data = json_data ) return response","title":"set_strategy_config()"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.api.AlgoBullsAPI.start_strategy_algotrading","text":"Submit Backtesting / Paper Trading / Real Trading job for strategy with code strategy_code & return the job ID. ENDPOINT POST v1/customer_strategy_algotrading Source code in pyalgotrading/algobulls/api.py 187 188 189 190 191 192 193 194 195 196 197 198 def start_strategy_algotrading ( self , strategy_code : str , trading_type : str , broker : str = '' ) -> dict : \"\"\" Submit Backtesting / Paper Trading / Real Trading job for strategy with code strategy_code & return the job ID. Info: ENDPOINT `POST` v1/customer_strategy_algotrading \"\"\" params = { 'strategyCode' : strategy_code , 'strategyType' : StrategyType . PYTHON . value , 'tradingType' : trading_type . value , 'broker' : broker } endpoint = f 'v1/customer_strategy_algotrading' json_data = { 'action' : 'start' } response = self . _send_request ( method = 'post' , endpoint = endpoint , params = params , json_data = json_data ) return response","title":"start_strategy_algotrading()"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.api.AlgoBullsAPI.stop_strategy_algotrading","text":"Stop Backtesting / Paper Trading / Real Trading job for strategy with code strategy_code & return the job ID. ENDPOINT POST v1/customer_strategy_algotrading Source code in pyalgotrading/algobulls/api.py 200 201 202 203 204 205 206 207 208 209 210 211 def stop_strategy_algotrading ( self , strategy_code : str , trading_type : str , broker : str = '' ) -> dict : \"\"\" Stop Backtesting / Paper Trading / Real Trading job for strategy with code strategy_code & return the job ID. Info: ENDPOINT `POST` v1/customer_strategy_algotrading \"\"\" params = { 'strategyCode' : strategy_code , 'strategyType' : StrategyType . PYTHON . value , 'tradingType' : trading_type . value , 'broker' : broker } endpoint = f 'v1/customer_strategy_algotrading' json_data = { 'action' : 'stop' } response = self . _send_request ( method = 'post' , endpoint = endpoint , params = params , json_data = json_data ) return response","title":"stop_strategy_algotrading()"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.api.AlgoBullsAPI.update_strategy","text":"Update an already existing strategy on the AlgoBulls platform Parameters: Name Type Description Default strategy_name str name of the strategy required strategy_details str Python code of the strategy required abc_version str value of one of the enums available under AlgoBullsEngineVersion required Returns: Type Description dict JSON Response received from AlgoBulls platform after (attempt to) updating an existing strategy. ENDPOINT PUT v2/user/strategy/build/python Source code in pyalgotrading/algobulls/api.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 def update_strategy ( self , strategy_name : str , strategy_details : str , abc_version : str ) -> dict : \"\"\" Update an already existing strategy on the AlgoBulls platform Args: strategy_name: name of the strategy strategy_details: Python code of the strategy abc_version: value of one of the enums available under `AlgoBullsEngineVersion` Returns: JSON Response received from AlgoBulls platform after (attempt to) updating an existing strategy. Info: ENDPOINT PUT v2/user/strategy/build/python \"\"\" json_data = { 'strategyName' : strategy_name , 'strategyDetails' : strategy_details , 'abcVersion' : abc_version } endpoint = f 'v2/user/strategy/build/python' response = self . _send_request ( endpoint = endpoint , method = 'put' , json_data = json_data ) return response","title":"update_strategy()"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.connection","text":"Module for AlgoBulls connection","title":"connection"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.connection.AlgoBullsConnection","text":"Class for Algobulls connection","title":"AlgoBullsConnection"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.connection.AlgoBullsConnection.__init__","text":"Init method that is used while creating an object of this class Source code in pyalgotrading/algobulls/connection.py 20 21 22 23 24 def __init__ ( self ): \"\"\" Init method that is used while creating an object of this class \"\"\" self . api = AlgoBullsAPI ()","title":"__init__()"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.connection.AlgoBullsConnection.backtest","text":"Parameters: Name Type Description Default strategy_code strategy code required start_timestamp start date/time required end_timestamp end date/time required instrument_id instrument key required strategy_parameters parameters required candle_interval candle interval required strategy_mode intraday or delivery <StrategyMode.INTRADAY: 0> Returns: Type Description backtest status Source code in pyalgotrading/algobulls/connection.py 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 def backtest ( self , strategy_code , start_timestamp , end_timestamp , instrument_id , strategy_parameters , candle_interval , strategy_mode = StrategyMode . INTRADAY ): \"\"\" Args: strategy_code: strategy code start_timestamp: start date/time end_timestamp: end date/time instrument_id: instrument key strategy_parameters: parameters candle_interval: candle interval strategy_mode: intraday or delivery Returns: backtest status \"\"\" # Sanity checks - Validate config parameters assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' assert ( isinstance ( start_timestamp , dt ) is True ), f 'Argument start_timestamp should be an instance of type datetime.datetime' assert ( isinstance ( end_timestamp , dt ) is True ), f 'Argument start_timestamp should be an instance of type datetime.datetime' assert ( isinstance ( instrument_id , int ) is True ), f 'Argument instrument_id should be a integer. You can find the right id using the \\' get_instrument() \\' method of AlgoBullsConnection class' assert ( isinstance ( strategy_parameters , dict ) is True ), f 'Argument strategy_parameters should be a dict' assert ( isinstance ( strategy_mode , StrategyMode ) is True ), f 'Argument strategy_mode should be enum of type StrategyMode' assert ( isinstance ( candle_interval , CandleInterval )), f 'Argument candle_interval should be an enum of type CandleInterval' # Setup config for Backtesting strategy_config = { 'trading_start_date' : start_timestamp . date (), 'trading_start_time' : start_timestamp . time (), 'trading_end_date' : end_timestamp . date (), 'trading_end_time' : end_timestamp . time (), 'instrument' : instrument_id , 'parameters' : json . dumps ( strategy_parameters ), 'candle_interval' : candle_interval . value , 'strategy_mode' : strategy_mode } print ( 'Setting Strategy Config...' , end = ' ' ) self . api . set_strategy_config ( strategy_code = strategy_code , strategy_config = strategy_config ) print ( 'Success.' ) # Submit Backtesting job print ( 'Submitting Backtesting Job...' , end = ' ' ) response = self . api . start_strategy_algotrading ( strategy_code = strategy_code , trading_type = TradingType . BACKTESTING ) print ( 'Success.' ) if response . get ( 'success' ) is True : return AlgoBullsJobSubmissionResponse ( response [ 'data' ] . upper ()) else : return AlgoBullsJobSubmissionResponse . ERROR , response","title":"backtest()"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.connection.AlgoBullsConnection.create_strategy","text":"Method to upload new strategy. All strategies are unique by name, per customer. If customer tries to upload strategy with the same name as an already existing strategy - if overwrite is False: - AlgoBullsAPIBadRequest Exception will be thrown. No change would be done in the backend database. If overwrite is True, - Existing strategy with strategy_name would be overwritten. No exception will be thrown. Source code in pyalgotrading/algobulls/connection.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def create_strategy ( self , strategy , overwrite = False ): \"\"\" Method to upload new strategy. All strategies are unique by name, per customer. If customer tries to upload strategy with the same name as an already existing strategy - if overwrite is False: - AlgoBullsAPIBadRequest Exception will be thrown. No change would be done in the backend database. If overwrite is True, - Existing strategy with strategy_name would be overwritten. No exception will be thrown. \"\"\" # Sanity checks assert issubclass ( strategy , StrategyBase ), f 'strategy should be a subclass of class StrategyBase. Got class of type: type { strategy } ' # Validate class by creating an instance print ( 'Validating Strategy...' ) strategy () # Get source code, and upload as new strategy (if strategy_code is None) else edit same strategy strategy_name = strategy . name () strategy_details = inspect . getsource ( strategy ) abc_version = strategy . versions_supported () . value # If strategy code is None, create a new strategy object try : response = self . api . create_strategy ( strategy_name = strategy_name , strategy_details = strategy_details , abc_version = abc_version ) except AlgoBullsAPIBadRequest as ex : if overwrite is True : # If strategy code is available, update the existing strategy response = self . api . update_strategy ( strategy_name = strategy_name , strategy_details = strategy_details , abc_version = abc_version ) else : raise ex return response","title":"create_strategy()"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.connection.AlgoBullsConnection.get_all_strategies","text":"Fetch all available strategies Returns: Type Description list of available strategies Source code in pyalgotrading/algobulls/connection.py 84 85 86 87 88 89 90 91 92 93 94 def get_all_strategies ( self ): \"\"\" Fetch all available strategies Returns: list of available strategies \"\"\" response = self . api . get_all_strategies () if isinstance ( response [ 'data' ], list ): return pd . DataFrame ( response [ 'data' ]) else : return response","title":"get_all_strategies()"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.connection.AlgoBullsConnection.get_authorization_url","text":"Fetches the authorization URL Returns: Type Description authorization URL Source code in pyalgotrading/algobulls/connection.py 26 27 28 29 30 31 32 33 34 def get_authorization_url ( self ): \"\"\" Fetches the authorization URL Returns: authorization URL \"\"\" url = 'https://devel.appv2.algobulls.com/user/login' # TODO: Update this when we move out of beta print ( f 'Please login to this URL with your AlgoBulls credentials and get your developer access token: { url } ' ) return url","title":"get_authorization_url()"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.connection.AlgoBullsConnection.get_backtesting_job_status","text":"Gets BACKTESTING job status for given strategy_code Source code in pyalgotrading/algobulls/connection.py 241 242 243 244 245 246 def get_backtesting_job_status ( self , strategy_code ): \"\"\" Gets BACKTESTING job status for given strategy_code \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' return self . get_job_status ( strategy_code , TradingType . BACKTESTING )","title":"get_backtesting_job_status()"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.connection.AlgoBullsConnection.get_backtesting_logs","text":"Fetch backtesting logs Parameters: Name Type Description Default strategy_code required Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 260 261 262 263 264 265 266 267 268 269 270 def get_backtesting_logs ( self , strategy_code ): \"\"\" Fetch backtesting logs Args: strategy_code: Returns: report details \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' return self . get_report ( strategy_code , trading_type = TradingType . BACKTESTING , report_type = TradingReportType . LOGS )","title":"get_backtesting_logs()"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.connection.AlgoBullsConnection.get_backtesting_report_order_history","text":"Fetch backtesting order history Parameters: Name Type Description Default strategy_code strategy code required Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 297 298 299 300 301 302 303 304 305 306 307 def get_backtesting_report_order_history ( self , strategy_code ): \"\"\" Fetch backtesting order history Args: strategy_code: strategy code Returns: report details \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' return self . get_report ( strategy_code = strategy_code , trading_type = TradingType . BACKTESTING , report_type = TradingReportType . ORDER_HISTORY )","title":"get_backtesting_report_order_history()"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.connection.AlgoBullsConnection.get_backtesting_report_pnl_table","text":"Fetch backtesting Profit / Loss details Parameters: Name Type Description Default strategy_code strategy code required show_all_rows True or False False Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 272 273 274 275 276 277 278 279 280 281 282 283 def get_backtesting_report_pnl_table ( self , strategy_code , show_all_rows = False ): \"\"\" Fetch backtesting Profit / Loss details Args: strategy_code: strategy code show_all_rows: True or False Returns: report details \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' return self . get_report ( strategy_code = strategy_code , trading_type = TradingType . BACKTESTING , report_type = TradingReportType . PNL_TABLE , render_as_dataframe = True , show_all_rows = show_all_rows )","title":"get_backtesting_report_pnl_table()"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.connection.AlgoBullsConnection.get_backtesting_report_statistics","text":"Fetch backtesting report statistics Parameters: Name Type Description Default strategy_code strategy code required Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 285 286 287 288 289 290 291 292 293 294 295 def get_backtesting_report_statistics ( self , strategy_code ): \"\"\" Fetch backtesting report statistics Args: strategy_code: strategy code Returns: report details \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' return self . get_report ( strategy_code = strategy_code , trading_type = TradingType . BACKTESTING , report_type = TradingReportType . STATS_TABLE , render_as_dataframe = True )","title":"get_backtesting_report_statistics()"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.connection.AlgoBullsConnection.get_job_status","text":"Gets job status for given strategy_code and trading_type Source code in pyalgotrading/algobulls/connection.py 128 129 130 131 132 133 134 135 136 137 138 139 140 def get_job_status ( self , strategy_code , trading_type , broker = None ): \"\"\" Gets job status for given strategy_code and trading_type \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' assert ( isinstance ( trading_type , TradingType ) is True ), f 'Argument trading_type should be an enum of type { TradingType . __name__ } ' assert ( broker is None or isinstance ( broker , AlgoBullsSupportedBrokers ) is True ), f 'Argument broker should be None or an enum of type { AlgoBullsSupportedBrokers . __name__ } ' response = self . api . get_job_status ( strategy_code = strategy_code , trading_type = trading_type , broker = broker . value ) if response . get ( 'success' ) is True : return AlgoBullsJobStatus ( response [ 'data' ] . upper ()) else : return AlgoBullsJobStatus . JOB_STATUS_UNKNOWN , response","title":"get_job_status()"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.connection.AlgoBullsConnection.get_papertrading_job_status","text":"Get papertrading job status Parameters: Name Type Description Default strategy_code required Returns: Type Description job status Source code in pyalgotrading/algobulls/connection.py 354 355 356 357 358 359 360 361 362 363 364 def get_papertrading_job_status ( self , strategy_code ): \"\"\" Get papertrading job status Args: strategy_code: Returns: job status \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' return self . get_job_status ( strategy_code , TradingType . PAPERTRADING )","title":"get_papertrading_job_status()"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.connection.AlgoBullsConnection.get_papertrading_logs","text":"Fetch papertesting logs Parameters: Name Type Description Default strategy_code strategy code required Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 378 379 380 381 382 383 384 385 386 387 388 def get_papertrading_logs ( self , strategy_code ): \"\"\" Fetch papertesting logs Args: strategy_code: strategy code Returns: report details \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' return self . get_report ( strategy_code = strategy_code , trading_type = TradingType . PAPERTRADING , report_type = TradingReportType . LOGS )","title":"get_papertrading_logs()"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.connection.AlgoBullsConnection.get_papertrading_report_order_history","text":"Fetch papertesting prder history Parameters: Name Type Description Default strategy_code strategy code required Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 415 416 417 418 419 420 421 422 423 424 425 def get_papertrading_report_order_history ( self , strategy_code ): \"\"\" Fetch papertesting prder history Args: strategy_code: strategy code Returns: report details \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' return self . get_report ( strategy_code = strategy_code , trading_type = TradingType . PAPERTRADING , report_type = TradingReportType . ORDER_HISTORY )","title":"get_papertrading_report_order_history()"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.connection.AlgoBullsConnection.get_papertrading_report_pnl_table","text":"Fetch papertesting Profit / Loss details Parameters: Name Type Description Default strategy_code strategy code required show_all_rows True or False False Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 390 391 392 393 394 395 396 397 398 399 400 401 def get_papertrading_report_pnl_table ( self , strategy_code , show_all_rows = False ): \"\"\" Fetch papertesting Profit / Loss details Args: strategy_code: strategy code show_all_rows: True or False Returns: report details \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' return self . get_report ( strategy_code = strategy_code , trading_type = TradingType . PAPERTRADING , report_type = TradingReportType . PNL_TABLE , render_as_dataframe = True , show_all_rows = show_all_rows )","title":"get_papertrading_report_pnl_table()"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.connection.AlgoBullsConnection.get_papertrading_report_statistics","text":"Fetch papertesting report statistics Parameters: Name Type Description Default strategy_code strategy code required Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 403 404 405 406 407 408 409 410 411 412 413 def get_papertrading_report_statistics ( self , strategy_code ): \"\"\" Fetch papertesting report statistics Args: strategy_code: strategy code Returns: report details \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' return self . get_report ( strategy_code = strategy_code , trading_type = TradingType . PAPERTRADING , report_type = TradingReportType . STATS_TABLE , render_as_dataframe = True )","title":"get_papertrading_report_statistics()"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.connection.AlgoBullsConnection.get_realtrading_job_status","text":"Fetch realtrading job status Parameters: Name Type Description Default broker broker name required strategy_code strategy code required Returns: Type Description job status Source code in pyalgotrading/algobulls/connection.py 474 475 476 477 478 479 480 481 482 483 484 485 486 487 def get_realtrading_job_status ( self , broker , strategy_code ): \"\"\" Fetch realtrading job status Args: broker: broker name strategy_code: strategy code Returns: job status \"\"\" assert ( isinstance ( broker , AlgoBullsSupportedBrokers ) is True ), f 'Argument broker should be an enum of type { AlgoBullsSupportedBrokers . __name__ } ' assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' return self . get_job_status ( strategy_code , TradingType . REALTRADING , broker = broker )","title":"get_realtrading_job_status()"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.connection.AlgoBullsConnection.get_realtrading_logs","text":"Fetch realtrading logs Parameters: Name Type Description Default broker broker name required strategy_code strategy code required Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 504 505 506 507 508 509 510 511 512 513 514 515 516 517 def get_realtrading_logs ( self , broker , strategy_code ): \"\"\" Fetch realtrading logs Args: broker: broker name strategy_code: strategy code Returns: report details \"\"\" assert ( isinstance ( broker , AlgoBullsSupportedBrokers ) is True ), f 'Argument broker should be an enum of type { AlgoBullsSupportedBrokers . __name__ } ' assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' return self . get_report ( strategy_code = strategy_code , trading_type = TradingType . REALTRADING , report_type = TradingReportType . LOGS , broker = broker )","title":"get_realtrading_logs()"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.connection.AlgoBullsConnection.get_realtrading_report_order_history","text":"Fetch realtrading order history Parameters: Name Type Description Default broker broker name required strategy_code strategy code required Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 550 551 552 553 554 555 556 557 558 559 560 561 562 563 def get_realtrading_report_order_history ( self , broker , strategy_code ): \"\"\" Fetch realtrading order history Args: broker: broker name strategy_code: strategy code Returns: report details \"\"\" assert ( isinstance ( broker , AlgoBullsSupportedBrokers ) is True ), f 'Argument broker should be an enum of type { AlgoBullsSupportedBrokers . __name__ } ' assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' return self . get_report ( strategy_code = strategy_code , trading_type = TradingType . REALTRADING , report_type = TradingReportType . ORDER_HISTORY , broker = broker )","title":"get_realtrading_report_order_history()"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.connection.AlgoBullsConnection.get_realtrading_report_pnl_table","text":"Fetch realtrading Profit / Loss table Parameters: Name Type Description Default broker broker name required strategy_code strategy code required show_all_rows True or False False Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 def get_realtrading_report_pnl_table ( self , broker , strategy_code , show_all_rows = False ): \"\"\" Fetch realtrading Profit / Loss table Args: broker: broker name strategy_code: strategy code show_all_rows: True or False Returns: report details \"\"\" assert ( isinstance ( broker , AlgoBullsSupportedBrokers ) is True ), f 'Argument broker should be an enum of type { AlgoBullsSupportedBrokers . __name__ } ' assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' return self . get_report ( strategy_code = strategy_code , trading_type = TradingType . REALTRADING , report_type = TradingReportType . PNL_TABLE , render_as_dataframe = True , show_all_rows = show_all_rows , broker = broker )","title":"get_realtrading_report_pnl_table()"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.connection.AlgoBullsConnection.get_realtrading_report_statistics","text":"Fetch realtrading report statistics Parameters: Name Type Description Default broker broker name required strategy_code strategy code required Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 535 536 537 538 539 540 541 542 543 544 545 546 547 548 def get_realtrading_report_statistics ( self , broker , strategy_code ): \"\"\" Fetch realtrading report statistics Args: broker: broker name strategy_code: strategy code Returns: report details \"\"\" assert ( isinstance ( broker , AlgoBullsSupportedBrokers ) is True ), f 'Argument broker should be an enum of type { AlgoBullsSupportedBrokers . __name__ } ' assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' return self . get_report ( strategy_code = strategy_code , trading_type = TradingType . REALTRADING , report_type = TradingReportType . STATS_TABLE , render_as_dataframe = True , broker = broker )","title":"get_realtrading_report_statistics()"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.connection.AlgoBullsConnection.get_report","text":"Fetch the report of a strategy Parameters: Name Type Description Default strategy_code strategy code required trading_type trading type required report_type report type required render_as_dataframe True or False False show_all_rows True or False False broker broker name None Returns: Type Description report details Source code in pyalgotrading/algobulls/connection.py 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 def get_report ( self , strategy_code , trading_type , report_type , render_as_dataframe = False , show_all_rows = False , broker = None ): \"\"\" Fetch the report of a strategy Args: strategy_code: strategy code trading_type: trading type report_type: report type render_as_dataframe: True or False show_all_rows: True or False broker: broker name Returns: report details \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' assert ( isinstance ( trading_type , TradingType ) is True ), f 'Argument trading_type should be an enum of type { TradingType . __name__ } ' assert ( isinstance ( report_type , TradingReportType ) is True ), f 'Argument report_type should be an enum of type { TradingReportType . __name__ } ' assert ( isinstance ( render_as_dataframe , bool ) is True ), f 'Argument render_as_dataframe should be a bool' assert ( isinstance ( show_all_rows , bool ) is True ), f 'Argument show_all_Rows should be a bool' assert ( broker is None or isinstance ( broker , AlgoBullsSupportedBrokers ) is True ), f 'Argument broker should be None or an enum of type { AlgoBullsSupportedBrokers . __name__ } ' response = self . api . get_reports ( strategy_code = strategy_code , trading_type = trading_type , report_type = report_type , broker = broker . value ) if response . get ( 'success' ) is True : if render_as_dataframe : if show_all_rows : pandas_dataframe_all_rows () _response = pd . DataFrame ( response [ 'data' ]) else : _response = response [ 'data' ] return _response else : return AlgoBullsJobSubmissionResponse . ERROR , response","title":"get_report()"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.connection.AlgoBullsConnection.get_strategy_details","text":"Fetch the strategy details of a particular strategy Parameters: Name Type Description Default strategy_code strategy code required Returns: Type Description strategy program / code Source code in pyalgotrading/algobulls/connection.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def get_strategy_details ( self , strategy_code ): \"\"\" Fetch the strategy details of a particular strategy Args: strategy_code: strategy code Returns: strategy program / code \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' try : response = self . api . get_strategy_details ( strategy_code ) strategy_code = response [ 'data' ] return strategy_code except AlgoBullsAPIBadRequest : print ( f 'ERROR: No strategy found with ID: { strategy_code } ' )","title":"get_strategy_details()"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.connection.AlgoBullsConnection.papertrade","text":"Start a paper trading session Parameters: Name Type Description Default strategy_code strategy code required start_time start time required end_time end time required instrument_id instrument key required strategy_parameters parameters required candle_interval candle interval required strategy_mode intraday or delivery <StrategyMode.INTRADAY: 0> Returns: Type Description job status Source code in pyalgotrading/algobulls/connection.py 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 def papertrade ( self , strategy_code , start_time , end_time , instrument_id , strategy_parameters , candle_interval , strategy_mode = StrategyMode . INTRADAY ): \"\"\" Start a paper trading session Args: strategy_code: strategy code start_time: start time end_time: end time instrument_id: instrument key strategy_parameters: parameters candle_interval: candle interval strategy_mode: intraday or delivery Returns: job status \"\"\" # Sanity checks - Validate config parameters assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' assert ( isinstance ( start_time , time ) is True ), f 'Argument start_timestamp should be an instance of type datetime.datetime' assert ( isinstance ( end_time , time ) is True ), f 'Argument start_timestamp should be an instance of type datetime.datetime' assert ( isinstance ( instrument_id , int ) is True ), f 'Argument instrument_id should be a integer. You can find the right id using the \\' get_instrument() \\' method of AlgoBullsConnection class' assert ( isinstance ( strategy_parameters , dict ) is True ), f 'Argument strategy_parameters should be a dict' assert ( isinstance ( strategy_mode , StrategyMode ) is True ), f 'Argument strategy_mode should be enum of type StrategyMode' assert ( isinstance ( candle_interval , CandleInterval )), f 'Argument candle_interval should be an enum of type CandleInterval' # Setup config for Paper Trading strategy_config = { 'trading_start_time' : start_time , 'trading_end_time' : end_time , 'instrument' : instrument_id , 'parameters' : json . dumps ( strategy_parameters ), 'candle_interval' : candle_interval . value , 'strategy_mode' : strategy_mode . value } print ( 'Setting Strategy Config...' , end = ' ' ) self . api . set_strategy_config ( strategy_code = strategy_code , strategy_config = strategy_config ) print ( 'Success.' ) # Submit Paper Trading job print ( 'Submitting Paper Trading Job...' , end = ' ' ) response = self . api . start_strategy_algotrading ( strategy_code = strategy_code , trading_type = TradingType . PAPERTRADING ) print ( 'Success.' ) if response . get ( 'success' ) is True : return AlgoBullsJobSubmissionResponse ( response [ 'data' ] . upper ()) else : return AlgoBullsJobSubmissionResponse . ERROR , response","title":"papertrade()"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.connection.AlgoBullsConnection.realtrade","text":"Start a realtrading session Parameters: Name Type Description Default broker broker name required strategy_code strategy code required start_time start time required end_time end time required instrument_id instrument key required strategy_parameters parameters required candle_interval candle interval required strategy_mode intraday or delivery <StrategyMode.INTRADAY: 0> Returns: Type Description job status Source code in pyalgotrading/algobulls/connection.py 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 def realtrade ( self , broker , strategy_code , start_time , end_time , instrument_id , strategy_parameters , candle_interval , strategy_mode = StrategyMode . INTRADAY ): \"\"\" Start a realtrading session Args: broker: broker name strategy_code: strategy code start_time: start time end_time: end time instrument_id: instrument key strategy_parameters: parameters candle_interval: candle interval strategy_mode: intraday or delivery Returns: job status \"\"\" # Sanity checks - Validate config parameters assert ( isinstance ( broker , AlgoBullsSupportedBrokers ) is True ), f 'Argument broker should be an enum of type { AlgoBullsSupportedBrokers . __name__ } ' assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' assert ( isinstance ( start_time , time ) is True ), f 'Argument start_time should be an instance of type datetime.time' assert ( isinstance ( end_time , time ) is True ), f 'Argument end_time should be an instance of type datetime.time' assert ( isinstance ( instrument_id , int ) is True ), f 'Argument instrument_id should be a integer. You can find the right id using the \\' get_instrument() \\' method of AlgoBullsConnection class' assert ( isinstance ( strategy_parameters , dict ) is True ), f 'Argument strategy_parameters should be a dict' assert ( isinstance ( strategy_mode , StrategyMode ) is True ), f 'Argument strategy_mode should be enum of type StrategyMode' assert ( isinstance ( candle_interval , CandleInterval )), f 'Argument candle_interval should be an enum of type CandleInterval' # Setup config for backtesting strategy_config = { 'trading_start_time' : start_time , 'trading_end_time' : end_time , 'instrument' : instrument_id , 'parameters' : json . dumps ( strategy_parameters ), 'candle_interval' : candle_interval . value , 'strategy_mode' : strategy_mode . value } print ( 'Setting Strategy Config...' , end = ' ' ) self . api . set_strategy_config ( strategy_code = strategy_code , strategy_config = strategy_config ) print ( 'Success.' ) # Submit Real Trading job print ( 'Submitting Real Trading Job...' , end = ' ' ) response = self . api . start_strategy_algotrading ( strategy_code = strategy_code , trading_type = TradingType . REALTRADING , broker = broker . value ) print ( 'Success.' ) if response . get ( 'success' ) is True : return AlgoBullsJobSubmissionResponse ( response [ 'data' ] . upper ()) else : return AlgoBullsJobSubmissionResponse . ERROR , response","title":"realtrade()"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.connection.AlgoBullsConnection.search_instrument","text":"Search for an instrument Parameters: Name Type Description Default instrument instrument key required Returns: Type Description True or False Source code in pyalgotrading/algobulls/connection.py 114 115 116 117 118 119 120 121 122 123 124 125 126 def search_instrument ( self , instrument ): \"\"\" Search for an instrument Args: instrument: instrument key Returns: True or False \"\"\" assert ( isinstance ( instrument , str ) is True ), f 'Argument instrument should be a string' response = self . api . search_instrument ( instrument )[ 'details' ] return response","title":"search_instrument()"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.connection.AlgoBullsConnection.set_access_token","text":"Set the access token Parameters: Name Type Description Default access_token access token required Returns: Type Description None Source code in pyalgotrading/algobulls/connection.py 36 37 38 39 40 41 42 43 44 45 46 def set_access_token ( self , access_token ): \"\"\" Set the access token Args: access_token: access token Returns: None \"\"\" assert ( isinstance ( access_token , str ) is True ), f 'Argument access_token should be a string' self . api . set_access_token ( access_token )","title":"set_access_token()"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.connection.AlgoBullsConnection.stop_backtesting_job","text":"Stops the BACKTESTING job Parameters: Name Type Description Default strategy_code Strategy Code / ID required Returns: Type Description None Source code in pyalgotrading/algobulls/connection.py 248 249 250 251 252 253 254 255 256 257 258 def stop_backtesting_job ( self , strategy_code ): \"\"\" Stops the BACKTESTING job Args: strategy_code: Strategy Code / ID Returns: None \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' return self . stop_job ( strategy_code = strategy_code , trading_type = TradingType . BACKTESTING )","title":"stop_backtesting_job()"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.connection.AlgoBullsConnection.stop_job","text":"Stops a job Parameters: Name Type Description Default strategy_code strategy code required trading_type trading type required broker broker name None Returns: Type Description job status Source code in pyalgotrading/algobulls/connection.py 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 def stop_job ( self , strategy_code , trading_type , broker = None ): \"\"\" Stops a job Args: strategy_code: strategy code trading_type: trading type broker: broker name Returns: job status \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' assert ( isinstance ( trading_type , TradingType ) is True ), f 'Argument trading_type should be an enum of type { TradingType . __name__ } ' assert ( broker is None or isinstance ( broker , AlgoBullsSupportedBrokers ) is True ), f 'Argument broker should be None or an enum of type { AlgoBullsSupportedBrokers . __name__ } ' response = self . api . stop_strategy_algotrading ( strategy_code = strategy_code , trading_type = trading_type , broker = broker . value ) if response . get ( 'success' ) is True : return AlgoBullsJobSubmissionResponse ( response [ 'data' ] . upper ()) else : return AlgoBullsJobSubmissionResponse . ERROR , response","title":"stop_job()"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.connection.AlgoBullsConnection.stop_papertrading_job","text":"Stop the papertrading session Parameters: Name Type Description Default strategy_code strategy code required Returns: Type Description None Source code in pyalgotrading/algobulls/connection.py 366 367 368 369 370 371 372 373 374 375 376 def stop_papertrading_job ( self , strategy_code ): \"\"\" Stop the papertrading session Args: strategy_code: strategy code Returns: None \"\"\" assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' return self . stop_job ( strategy_code = strategy_code , trading_type = TradingType . PAPERTRADING )","title":"stop_papertrading_job()"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.connection.AlgoBullsConnection.stop_realtrading_job","text":"Stop the realtrading session Parameters: Name Type Description Default broker brker name required strategy_code strategy code required Returns: Type Description None Source code in pyalgotrading/algobulls/connection.py 489 490 491 492 493 494 495 496 497 498 499 500 501 502 def stop_realtrading_job ( self , broker , strategy_code ): \"\"\" Stop the realtrading session Args: broker: brker name strategy_code: strategy code Returns: None \"\"\" assert ( isinstance ( broker , AlgoBullsSupportedBrokers ) is True ), f 'Argument broker should be an enum of type { AlgoBullsSupportedBrokers . __name__ } ' assert ( isinstance ( strategy_code , str ) is True ), f 'Argument strategy_code should be a string' return self . stop_job ( strategy_code = strategy_code , trading_type = TradingType . REALTRADING , broker = broker )","title":"stop_realtrading_job()"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.connection.pandas_dataframe_all_rows","text":"Returns: None Source code in pyalgotrading/algobulls/connection.py 566 567 568 569 570 571 572 573 574 575 def pandas_dataframe_all_rows (): \"\"\" Returns: None \"\"\" pd . set_option ( 'display.max_rows' , None ) pd . set_option ( 'display.max_columns' , None ) pd . set_option ( 'display.width' , None ) pd . set_option ( 'display.max_colwidth' , None )","title":"pandas_dataframe_all_rows()"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.exceptions","text":"","title":"exceptions"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.exceptions.AlgoBullsAPIBadRequest","text":"Exception class for HTTP status code of 400 (Bad Request)","title":"AlgoBullsAPIBadRequest"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.exceptions.AlgoBullsAPIBaseException","text":"Base exception class for all API related exceptions","title":"AlgoBullsAPIBaseException"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.exceptions.AlgoBullsAPIInternalServerErrorException","text":"Exception class for HTTP status code of 500 (Internal Server Error)","title":"AlgoBullsAPIInternalServerErrorException"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.exceptions.AlgoBullsAPIResourceNotFoundError","text":"Exception class for HTTP status code of 404 (Resource Not Found)","title":"AlgoBullsAPIResourceNotFoundError"},{"location":"package_pyalgotrading/#pyalgotrading.algobulls.exceptions.AlgoBullsAPIUnauthorizedError","text":"Exception class for HTTP status code of 401 (Unauthorized)","title":"AlgoBullsAPIUnauthorizedError"},{"location":"package_pyalgotrading/#pyalgotrading.broker","text":"","title":"broker"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_base","text":"Base class for Broker Connection","title":"broker_connection_base"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_base.BrokerConnectionBase","text":"Base class for Broker Connection","title":"BrokerConnectionBase"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_base.BrokerConnectionBase.get_all_instruments","text":"All instruments enlisted by the broker Returns: Type Description list of all instruments Source code in pyalgotrading/broker/broker_connection_base.py 20 21 22 23 24 25 26 27 @abstractmethod def get_all_instruments ( self ): \"\"\" All instruments enlisted by the broker Returns: list of all instruments \"\"\" raise NotImplementedError","title":"get_all_instruments()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_base.BrokerConnectionBase.get_circuit_limits","text":"Fetch the circuit limits Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description circuit limit value Source code in pyalgotrading/broker/broker_connection_base.py 55 56 57 58 59 60 61 62 63 64 65 66 @abstractmethod def get_circuit_limits ( self , * args , ** kwargs ): \"\"\" Fetch the circuit limits Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: circuit limit value \"\"\" raise NotImplementedError","title":"get_circuit_limits()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_base.BrokerConnectionBase.get_close_price_last_day","text":"Fetch the closed price of the day Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description closed price value Source code in pyalgotrading/broker/broker_connection_base.py 185 186 187 188 189 190 191 192 193 194 195 196 @abstractmethod def get_close_price_last_day ( self , * args , ** kwargs ): \"\"\" Fetch the closed price of the day Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: closed price value \"\"\" raise NotImplementedError","title":"get_close_price_last_day()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_base.BrokerConnectionBase.get_funds","text":"Fetch the available funds Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description available funds value Source code in pyalgotrading/broker/broker_connection_base.py 226 227 228 229 230 231 232 233 234 235 236 237 @abstractmethod def get_funds ( self , * args , ** kwargs ): \"\"\" Fetch the available funds Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: available funds value \"\"\" raise NotImplementedError","title":"get_funds()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_base.BrokerConnectionBase.get_high_price_day","text":"Fetch the high price of the day Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description high price value Source code in pyalgotrading/broker/broker_connection_base.py 159 160 161 162 163 164 165 166 167 168 169 170 @abstractmethod def get_high_price_day ( self , * args , ** kwargs ): \"\"\" Fetch the high price of the day Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: high price value \"\"\" raise NotImplementedError","title":"get_high_price_day()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_base.BrokerConnectionBase.get_historical_data","text":"Fetch the historical data Parameters: Name Type Description Default instrument instrument key required candle_interval candle interval required start_date date from which to fetch the historical data required end_date date till which to fetch the historical data required Returns: Type Description historical data Source code in pyalgotrading/broker/broker_connection_base.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 @abstractmethod def get_historical_data ( self , instrument , candle_interval , start_date , end_date ): \"\"\" Fetch the historical data Args: instrument: instrument key candle_interval: candle interval start_date: date from which to fetch the historical data end_date: date till which to fetch the historical data Returns: historical data \"\"\" raise NotImplementedError","title":"get_historical_data()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_base.BrokerConnectionBase.get_instrument","text":"Fetch a single instrument Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description a single instrument Source code in pyalgotrading/broker/broker_connection_base.py 29 30 31 32 33 34 35 36 37 38 39 40 @abstractmethod def get_instrument ( self , * args , ** kwargs ): \"\"\" Fetch a single instrument Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: a single instrument \"\"\" raise NotImplementedError","title":"get_instrument()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_base.BrokerConnectionBase.get_low_price_day","text":"Fetch the low price of the day Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description low price value Source code in pyalgotrading/broker/broker_connection_base.py 172 173 174 175 176 177 178 179 180 181 182 183 @abstractmethod def get_low_price_day ( self , * args , ** kwargs ): \"\"\" Fetch the low price of the day Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: low price value \"\"\" raise NotImplementedError","title":"get_low_price_day()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_base.BrokerConnectionBase.get_ltp","text":"Fetch the Last Trading Price (LTP) Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description ltp value Source code in pyalgotrading/broker/broker_connection_base.py 68 69 70 71 72 73 74 75 76 77 78 79 @abstractmethod def get_ltp ( self , * args , ** kwargs ): \"\"\" Fetch the Last Trading Price (LTP) Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: ltp value \"\"\" raise NotImplementedError","title":"get_ltp()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_base.BrokerConnectionBase.get_ltq","text":"Fetch the Last Trading Quantity (LTQ) Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description ltq value Source code in pyalgotrading/broker/broker_connection_base.py 94 95 96 97 98 99 100 101 102 103 104 105 @abstractmethod def get_ltq ( self , * args , ** kwargs ): \"\"\" Fetch the Last Trading Quantity (LTQ) Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: ltq value \"\"\" raise NotImplementedError","title":"get_ltq()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_base.BrokerConnectionBase.get_ltt","text":"Fetch the Last Trading Time (LTT) Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description ltt value Source code in pyalgotrading/broker/broker_connection_base.py 81 82 83 84 85 86 87 88 89 90 91 92 @abstractmethod def get_ltt ( self , * args , ** kwargs ): \"\"\" Fetch the Last Trading Time (LTT) Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: ltt value \"\"\" raise NotImplementedError","title":"get_ltt()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_base.BrokerConnectionBase.get_margins","text":"Fetch the margins Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description margin value Source code in pyalgotrading/broker/broker_connection_base.py 213 214 215 216 217 218 219 220 221 222 223 224 @abstractmethod def get_margins ( self , * args , ** kwargs ): \"\"\" Fetch the margins Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: margin value \"\"\" raise NotImplementedError","title":"get_margins()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_base.BrokerConnectionBase.get_market_depth","text":"Fetch the market depth Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description market depth value Source code in pyalgotrading/broker/broker_connection_base.py 42 43 44 45 46 47 48 49 50 51 52 53 @abstractmethod def get_market_depth ( self , * args , ** kwargs ): \"\"\" Fetch the market depth Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: market depth value \"\"\" raise NotImplementedError","title":"get_market_depth()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_base.BrokerConnectionBase.get_name","text":"Name of the broker Returns: Type Description broker name Source code in pyalgotrading/broker/broker_connection_base.py 11 12 13 14 15 16 17 18 @abstractmethod def get_name ( self ): \"\"\" Name of the broker Returns: broker name \"\"\" raise NotImplementedError","title":"get_name()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_base.BrokerConnectionBase.get_open_price_day","text":"Fetch the open price of the day Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description open price value Source code in pyalgotrading/broker/broker_connection_base.py 146 147 148 149 150 151 152 153 154 155 156 157 @abstractmethod def get_open_price_day ( self , * args , ** kwargs ): \"\"\" Fetch the open price of the day Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: open price value \"\"\" raise NotImplementedError","title":"get_open_price_day()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_base.BrokerConnectionBase.get_order_status","text":"Fetch the status of the order Parameters: Name Type Description Default order_id order id required Returns: Type Description the status of the order Source code in pyalgotrading/broker/broker_connection_base.py 270 271 272 273 274 275 276 277 278 279 280 @abstractmethod def get_order_status ( self , order_id ): \"\"\" Fetch the status of the order Args: order_id: order id Returns: the status of the order \"\"\" raise NotImplementedError","title":"get_order_status()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_base.BrokerConnectionBase.get_profile","text":"Fetch the profile Returns: Type Description profile information Source code in pyalgotrading/broker/broker_connection_base.py 239 240 241 242 243 244 245 246 @abstractmethod def get_profile ( self ): \"\"\" Fetch the profile Returns: profile information \"\"\" raise NotImplementedError","title":"get_profile()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_base.BrokerConnectionBase.get_total_buy_quantity_day","text":"Fetch the total buy quantity for the day Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description total quantity value Source code in pyalgotrading/broker/broker_connection_base.py 107 108 109 110 111 112 113 114 115 116 117 118 @abstractmethod def get_total_buy_quantity_day ( self , * args , ** kwargs ): \"\"\" Fetch the total buy quantity for the day Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: total quantity value \"\"\" raise NotImplementedError","title":"get_total_buy_quantity_day()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_base.BrokerConnectionBase.get_total_sell_quantity_day","text":"Fetch the total sell quantity for the day Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description total quantity value Source code in pyalgotrading/broker/broker_connection_base.py 120 121 122 123 124 125 126 127 128 129 130 131 @abstractmethod def get_total_sell_quantity_day ( self , * args , ** kwargs ): \"\"\" Fetch the total sell quantity for the day Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: total quantity value \"\"\" raise NotImplementedError","title":"get_total_sell_quantity_day()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_base.BrokerConnectionBase.get_total_volume_day","text":"Fetch the total volume for the day Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Returns: Type Description total volume value Source code in pyalgotrading/broker/broker_connection_base.py 133 134 135 136 137 138 139 140 141 142 143 144 @abstractmethod def get_total_volume_day ( self , * args , ** kwargs ): \"\"\" Fetch the total volume for the day Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list Returns: total volume value \"\"\" raise NotImplementedError","title":"get_total_volume_day()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_base.BrokerConnectionBase.place_order","text":"Place an order Parameters: Name Type Description Default instrument instrument key required order_transaction_type buy or sell required order_type regular or bracket required order_code orde code required order_variety market / limit / stoploss market / stoploss limit required quantity quantity required price amount / value None trigger_price trigger price amount / value None stoploss_trigger stoploss trigger amount / value None target_trigger target trigger amount / value None trailing_stoploss_trigger trailing stoploss trigger amount / value None Returns: Type Description order id Source code in pyalgotrading/broker/broker_connection_base.py 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 @abstractmethod def place_order ( self , instrument , order_transaction_type , order_type , order_code , order_variety , quantity , price = None , trigger_price = None , stoploss_trigger = None , target_trigger = None , trailing_stoploss_trigger = None ): \"\"\" Place an order Args: instrument: instrument key order_transaction_type: buy or sell order_type: regular or bracket order_code: orde code order_variety: market / limit / stoploss market / stoploss limit quantity: quantity price: amount / value trigger_price: trigger price amount / value stoploss_trigger: stoploss trigger amount / value target_trigger: target trigger amount / value trailing_stoploss_trigger: trailing stoploss trigger amount / value Returns: order id \"\"\" raise NotImplementedError","title":"place_order()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_zerodha","text":"Module for class BrokerConnectionZerodha","title":"broker_connection_zerodha"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha","text":"class for Broker Connection Zerodha","title":"BrokerConnectionZerodha"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.__init__","text":"Init method that is used while creating an object of this class Parameters: Name Type Description Default api_key api key given by the broker required api_secret api secret to be used for making an authenticated connection with the broker required Source code in pyalgotrading/broker/broker_connection_zerodha.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def __init__ ( self , api_key , api_secret ): \"\"\" Init method that is used while creating an object of this class Args: api_key: api key given by the broker api_secret: api secret to be used for making an authenticated connection with the broker \"\"\" self . api_key = api_key self . api_secret = api_secret # Create kiteconnect instance kiteconnect = import_with_install ( package_import_name = 'kiteconnect' , package_install_name = 'kiteconnect' , package_version = '3.8.2' ) self . api = kiteconnect . KiteConnect ( api_key = self . api_key ) # Print the login url. User will use this to login to broker site and get access token print ( f 'Please login to this link to generate your request token: { self . api . login_url () } ' ) # Create other attributes self . all_instruments = None self . populate_constants ()","title":"__init__()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.cancel_order","text":"Cancel an order Parameters: Name Type Description Default order_id order id required order_type order type required Returns: Type Description Order Status Source code in pyalgotrading/broker/broker_connection_zerodha.py 379 380 381 382 383 384 385 386 387 388 389 390 def cancel_order ( self , order_id , order_type ): \"\"\" Cancel an order Args: order_id: order id order_type: order type Returns: Order Status \"\"\" _variety = BrokerConnectionZerodha . ORDER_TYPE_MAP [ order_type ] # What we call as 'Order Type', Zerodha calls it as 'variety' return self . api . cancel_order ( variety = _variety , order_id = order_id )","title":"cancel_order()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.get_all_instruments","text":"Fetches all instruments Returns: Type Description list of all instruments Source code in pyalgotrading/broker/broker_connection_zerodha.py 86 87 88 89 90 91 92 93 def get_all_instruments ( self ): \"\"\" Fetches all instruments Returns: list of all instruments \"\"\" self . all_instruments = pd . DataFrame ( self . api . instruments ()) return self . all_instruments","title":"get_all_instruments()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.get_circuit_limits","text":"Fetch the circuit limits Parameters: Name Type Description Default segment segment required tradingsymbol trading symbol required Returns: Type Description circuit limit value Source code in pyalgotrading/broker/broker_connection_zerodha.py 138 139 140 141 142 143 144 145 146 147 148 149 150 151 def get_circuit_limits ( self , segment , tradingsymbol ): \"\"\" Fetch the circuit limits Args: segment: segment tradingsymbol: trading symbol Returns: circuit limit value \"\"\" quote = self . get_quote ( segment , tradingsymbol ) lower_circuit_limit = quote [ 'lower_circuit_limit' ] upper_circuit_limit = quote [ 'upper_circuit_limit' ] return lower_circuit_limit , upper_circuit_limit","title":"get_circuit_limits()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.get_close_price_last_day","text":"Fetch the closed price of the day Parameters: Name Type Description Default segment segment required tradingsymbol trading symbol required Returns: Type Description closed price value Source code in pyalgotrading/broker/broker_connection_zerodha.py 279 280 281 282 283 284 285 286 287 288 289 290 291 def get_close_price_last_day ( self , segment , tradingsymbol ): \"\"\" Fetch the closed price of the day Args: segment: segment tradingsymbol: trading symbol Returns: closed price value \"\"\" quote = self . get_quote ( segment , tradingsymbol ) close_price_day = quote [ 'ohlc' ][ 'close' ] return close_price_day","title":"get_close_price_last_day()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.get_funds","text":"Fetch the available funds Parameters: Name Type Description Default segment segment required Returns: Type Description available funds value Source code in pyalgotrading/broker/broker_connection_zerodha.py 321 322 323 324 325 326 327 328 329 330 331 332 def get_funds ( self , segment ): \"\"\" Fetch the available funds Args: segment: segment Returns: available funds value \"\"\" list_permissible_segments = [ 'equity' , 'commodity' ] assert ( segment in list_permissible_segments ), f 'segment should be one of { list_permissible_segments } ' return self . api . margins ( segment = segment )[ 'net' ]","title":"get_funds()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.get_high_price_day","text":"Fetch the high price of the day Parameters: Name Type Description Default segment segment required tradingsymbol trading symbol required Returns: Type Description high price value Source code in pyalgotrading/broker/broker_connection_zerodha.py 251 252 253 254 255 256 257 258 259 260 261 262 263 def get_high_price_day ( self , segment , tradingsymbol ): \"\"\" Fetch the high price of the day Args: segment: segment tradingsymbol: trading symbol Returns: high price value \"\"\" quote = self . get_quote ( segment , tradingsymbol ) high_price_day = quote [ 'ohlc' ][ 'high' ] return high_price_day","title":"get_high_price_day()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.get_historical_data","text":"Fetch the historical data Parameters: Name Type Description Default instrument instrument key required candle_interval candle interval required start_date date from which to fetch the historical data required end_date date till which to fetch the historical data required Returns: Type Description historical data Source code in pyalgotrading/broker/broker_connection_zerodha.py 293 294 295 296 297 298 299 300 301 302 303 304 305 306 def get_historical_data ( self , instrument , candle_interval , start_date , end_date ): \"\"\" Fetch the historical data Args: instrument: instrument key candle_interval: candle interval start_date: date from which to fetch the historical data end_date: date till which to fetch the historical data Returns: historical data \"\"\" return pd . DataFrame ( self . api . historical_data ( instrument [ 'instrument_token' ], from_date = start_date , to_date = end_date , interval = candle_interval )) \\ . reindex ([ 'date' , 'open' , 'high' , 'low' , 'close' , 'volume' ], axis = \"columns\" ) . rename ( columns = { 'date' : 'timestamp' })","title":"get_historical_data()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.get_instrument","text":"Fetch an instrument Parameters: Name Type Description Default segment segment required tradingsymbol trading symbol required Returns: Type Description instrument Source code in pyalgotrading/broker/broker_connection_zerodha.py 95 96 97 98 99 100 101 102 103 104 105 106 107 def get_instrument ( self , segment , tradingsymbol ): \"\"\" Fetch an instrument Args: segment: segment tradingsymbol: trading symbol Returns: instrument \"\"\" if self . all_instruments is None : self . all_instruments = self . get_all_instruments () return self . all_instruments [( self . all_instruments . segment == segment ) & ( self . all_instruments . tradingsymbol == tradingsymbol )] . iloc [ 0 ]","title":"get_instrument()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.get_low_price_day","text":"Fetch the low price of the day Parameters: Name Type Description Default segment segment required tradingsymbol trading symbol required Returns: Type Description low price value Source code in pyalgotrading/broker/broker_connection_zerodha.py 265 266 267 268 269 270 271 272 273 274 275 276 277 def get_low_price_day ( self , segment , tradingsymbol ): \"\"\" Fetch the low price of the day Args: segment: segment tradingsymbol: trading symbol Returns: low price value \"\"\" quote = self . get_quote ( segment , tradingsymbol ) low_price_day = quote [ 'ohlc' ][ 'low' ] return low_price_day","title":"get_low_price_day()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.get_ltp","text":"Fetch the Last Trading Price (LTP) Parameters: Name Type Description Default segment segment required tradingsymbol trading symbol required Returns: Type Description ltp value Source code in pyalgotrading/broker/broker_connection_zerodha.py 153 154 155 156 157 158 159 160 161 162 163 164 165 def get_ltp ( self , segment , tradingsymbol ): \"\"\" Fetch the Last Trading Price (LTP) Args: segment: segment tradingsymbol: trading symbol Returns: ltp value \"\"\" quote = self . get_quote ( segment , tradingsymbol ) ltp = quote [ 'last_price' ] return ltp","title":"get_ltp()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.get_ltq","text":"Fetch the Last Trading Quantity (LTQ) Parameters: Name Type Description Default segment segment required tradingsymbol trading symbol required Returns: Type Description ltq value Source code in pyalgotrading/broker/broker_connection_zerodha.py 181 182 183 184 185 186 187 188 189 190 191 192 193 def get_ltq ( self , segment , tradingsymbol ): \"\"\" Fetch the Last Trading Quantity (LTQ) Args: segment: segment tradingsymbol: trading symbol Returns: ltq value \"\"\" quote = self . get_quote ( segment , tradingsymbol ) ltq = quote [ 'last_quantity' ] return ltq","title":"get_ltq()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.get_ltt","text":"Fetch the Last Trading Time (LTT) Parameters: Name Type Description Default segment segment required tradingsymbol trading symbol required Returns: Type Description ltt value Source code in pyalgotrading/broker/broker_connection_zerodha.py 167 168 169 170 171 172 173 174 175 176 177 178 179 def get_ltt ( self , segment , tradingsymbol ): \"\"\" Fetch the Last Trading Time (LTT) Args: segment: segment tradingsymbol: trading symbol Returns: ltt value \"\"\" quote = self . get_quote ( segment , tradingsymbol ) ltt = quote [ 'last_trade_time' ] return ltt","title":"get_ltt()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.get_margins","text":"Fetch the margins Parameters: Name Type Description Default segment segment required Returns: Type Description margin value Source code in pyalgotrading/broker/broker_connection_zerodha.py 308 309 310 311 312 313 314 315 316 317 318 319 def get_margins ( self , segment ): \"\"\" Fetch the margins Args: segment: segment Returns: margin value \"\"\" list_permissible_segments = [ 'equity' , 'commodity' ] assert ( segment in list_permissible_segments ), f 'segment should be one of { list_permissible_segments } ' return self . api . margins ( segment = segment )","title":"get_margins()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.get_market_depth","text":"Fetch the market depth Parameters: Name Type Description Default segment segment required tradingsymbol trading symbol required Returns: Type Description market depth value Source code in pyalgotrading/broker/broker_connection_zerodha.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 def get_market_depth ( self , segment , tradingsymbol ): \"\"\" Fetch the market depth Args: segment: segment tradingsymbol: trading symbol Returns: market depth value \"\"\" quote = self . get_quote ( segment , tradingsymbol ) buy_market_depth = pd . DataFrame ( quote [ 'depth' ][ 'buy' ]) sell_market_depth = pd . DataFrame ( quote [ 'depth' ][ 'sell' ]) return buy_market_depth , sell_market_depth","title":"get_market_depth()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.get_name","text":"Fetch the name of the broker Returns: Type Description name of the broker Source code in pyalgotrading/broker/broker_connection_zerodha.py 43 44 45 46 47 48 49 def get_name ( self ): \"\"\" Fetch the name of the broker Returns: name of the broker \"\"\" return 'ZERODHA'","title":"get_name()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.get_open_price_day","text":"Fetch the open price of the day Parameters: Name Type Description Default segment segment required tradingsymbol trading symbol required Returns: Type Description open price value Source code in pyalgotrading/broker/broker_connection_zerodha.py 237 238 239 240 241 242 243 244 245 246 247 248 249 def get_open_price_day ( self , segment , tradingsymbol ): \"\"\" Fetch the open price of the day Args: segment: segment tradingsymbol: trading symbol Returns: open price value \"\"\" quote = self . get_quote ( segment , tradingsymbol ) open_price_day = quote [ 'ohlc' ][ 'open' ] return open_price_day","title":"get_open_price_day()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.get_order_status","text":"Fetch the status of the order Parameters: Name Type Description Default order_id order id required Returns: Type Description the status of the order Source code in pyalgotrading/broker/broker_connection_zerodha.py 368 369 370 371 372 373 374 375 376 377 def get_order_status ( self , order_id ): \"\"\" Fetch the status of the order Args: order_id: order id Returns: the status of the order \"\"\" return self . api . order_history ( order_id )[ - 1 ][ 'status' ]","title":"get_order_status()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.get_profile","text":"Fetch the profile Returns: Type Description profile information Source code in pyalgotrading/broker/broker_connection_zerodha.py 334 335 336 337 338 339 340 def get_profile ( self ): \"\"\" Fetch the profile Returns: profile information \"\"\" return self . api . profile ()","title":"get_profile()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.get_quote","text":"Fetch the quote Parameters: Name Type Description Default segment required tradingsymbol required Returns: Type Description quote value Source code in pyalgotrading/broker/broker_connection_zerodha.py 109 110 111 112 113 114 115 116 117 118 119 120 121 def get_quote ( self , segment , tradingsymbol ): \"\"\" Fetch the quote Args: segment: tradingsymbol: Returns: quote value \"\"\" instrument = f ' { segment } : { tradingsymbol } ' quote = self . api . quote ([ instrument ])[ instrument ] return quote","title":"get_quote()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.get_total_buy_quantity_day","text":"Fetch the total buy quantity for the day Parameters: Name Type Description Default segment segment required tradingsymbol trading symbol required Returns: Type Description total quantity value Source code in pyalgotrading/broker/broker_connection_zerodha.py 195 196 197 198 199 200 201 202 203 204 205 206 207 def get_total_buy_quantity_day ( self , segment , tradingsymbol ): \"\"\" Fetch the total buy quantity for the day Args: segment: segment tradingsymbol: trading symbol Returns: total quantity value \"\"\" quote = self . get_quote ( segment , tradingsymbol ) total_buy_quantity_day = quote [ 'buy_quantity' ] return total_buy_quantity_day","title":"get_total_buy_quantity_day()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.get_total_sell_quantity_day","text":"Fetch the total sell quantity for the day Parameters: Name Type Description Default segment segment required tradingsymbol trading symbol required Returns: Type Description total quantity value Source code in pyalgotrading/broker/broker_connection_zerodha.py 209 210 211 212 213 214 215 216 217 218 219 220 221 def get_total_sell_quantity_day ( self , segment , tradingsymbol ): \"\"\" Fetch the total sell quantity for the day Args: segment: segment tradingsymbol: trading symbol Returns: total quantity value \"\"\" quote = self . get_quote ( segment , tradingsymbol ) total_sell_quantity_day = quote [ 'sell_quantity' ] return total_sell_quantity_day","title":"get_total_sell_quantity_day()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.get_total_volume_day","text":"Fetch the total volume for the day Parameters: Name Type Description Default segment segment required tradingsymbol trading symbol required Returns: Type Description total volume value Source code in pyalgotrading/broker/broker_connection_zerodha.py 223 224 225 226 227 228 229 230 231 232 233 234 235 def get_total_volume_day ( self , segment , tradingsymbol ): \"\"\" Fetch the total volume for the day Args: segment: segment tradingsymbol: trading symbol Returns: total volume value \"\"\" quote = self . get_quote ( segment , tradingsymbol ) total_volume_day = quote [ 'volume' ] return total_volume_day","title":"get_total_volume_day()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.place_order","text":"Place an order Parameters: Name Type Description Default instrument instrument key required order_transaction_type buy or sell required order_type regular or bracket required order_code orde code required order_variety market / limit / stoploss market / stoploss limit required quantity quantity required price amount / value None trigger_price trigger price amount / value None stoploss stoploss amount / value None target target amount / value None trailing_stoploss trailing stoploss amount / value None Returns: Type Description Order status Source code in pyalgotrading/broker/broker_connection_zerodha.py 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 def place_order ( self , instrument , order_transaction_type , order_type , order_code , order_variety , quantity , price = None , trigger_price = None , stoploss = None , target = None , trailing_stoploss = None ): \"\"\" Place an order Args: instrument: instrument key order_transaction_type: buy or sell order_type: regular or bracket order_code: orde code order_variety: market / limit / stoploss market / stoploss limit quantity: quantity price: amount / value trigger_price: trigger price amount / value stoploss: stoploss amount / value target: target amount / value trailing_stoploss: trailing stoploss amount / value Returns: Order status \"\"\" _variety = BrokerConnectionZerodha . ORDER_TYPE_MAP [ order_type ] # what we call as 'Order Type', Zerodha calls it as 'variety' _transaction_type = BrokerConnectionZerodha . ORDER_TRANSACTION_TYPE_MAP [ order_transaction_type ] _product = BrokerConnectionZerodha . ORDER_CODE_MAP [ order_code ] # what we call as 'Order Code', Zerodha calls it as 'product' _order_type = BrokerConnectionZerodha . ORDER_VARIETY_MAP [ order_variety ] # What we call as 'Order Variety', Zerodha calls it as 'order_type' return self . api . place_order ( variety = _variety , exchange = instrument . exchange , tradingsymbol = instrument . tradingsymbol , transaction_type = _transaction_type , quantity = quantity , product = _product , order_type = _order_type , price = price , trigger_price = trigger_price , squareoff = target , stoploss = stoploss , trailing_stoploss = trailing_stoploss )","title":"place_order()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.populate_constants","text":"Map pyalgotrading constants to broker constants :return: None Source code in pyalgotrading/broker/broker_connection_zerodha.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def populate_constants ( self ): \"\"\" Map pyalgotrading constants to broker constants :return: None \"\"\" _ = import_with_install ( package_import_name = 'kiteconnect' , package_install_name = 'kiteconnect' , package_version = '3.8.2' ) . KiteConnect BrokerConnectionZerodha . ORDER_TRANSACTION_TYPE_MAP = { BrokerOrderTransactionTypeConstants . BUY : _ . TRANSACTION_TYPE_BUY , BrokerOrderTransactionTypeConstants . SELL : _ . TRANSACTION_TYPE_SELL } BrokerConnectionZerodha . ORDER_TYPE_MAP = { BrokerOrderTypeConstants . REGULAR : _ . VARIETY_REGULAR , BrokerOrderTypeConstants . BRACKET : _ . VARIETY_BO , BrokerOrderTypeConstants . COVER : _ . VARIETY_CO , BrokerOrderTypeConstants . AMO : _ . VARIETY_AMO } BrokerConnectionZerodha . ORDER_CODE_MAP = { BrokerOrderCodeConstants . INTRADAY : _ . PRODUCT_MIS , BrokerOrderCodeConstants . DELIVERY : _ . PRODUCT_CNC } BrokerConnectionZerodha . ORDER_VARIETY_MAP = { BrokerOrderVarietyConstants . MARKET : _ . ORDER_TYPE_MARKET , BrokerOrderVarietyConstants . LIMIT : _ . ORDER_TYPE_LIMIT , BrokerOrderVarietyConstants . STOPLOSS_LIMIT : _ . ORDER_TYPE_SL , BrokerOrderVarietyConstants . STOPLOSS_MARKET : _ . ORDER_TYPE_SLM }","title":"populate_constants()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.broker_connection_zerodha.BrokerConnectionZerodha.set_access_token","text":"Sets the access token Parameters: Name Type Description Default request_token the request token required Returns: Type Description None Source code in pyalgotrading/broker/broker_connection_zerodha.py 74 75 76 77 78 79 80 81 82 83 84 def set_access_token ( self , request_token ): \"\"\" Sets the access token Args: request_token: the request token Returns: None \"\"\" data = self . api . generate_session ( request_token , api_secret = self . api_secret ) self . api . set_access_token ( data [ \"access_token\" ])","title":"set_access_token()"},{"location":"package_pyalgotrading/#pyalgotrading.broker.utils","text":"Module for calculating crossover","title":"utils"},{"location":"package_pyalgotrading/#pyalgotrading.broker.utils.crossover","text":"Computes crossover of 2 data series - val1_hist and val2_hist. Parameters: Name Type Description Default val1_hist Union[Tuple, List, pandas.core.series.Series] Any object which can be converted to a list of data points. (Ex: pandas.Series, tuple, list) required val2_hist Union[Tuple, List, pandas.core.series.Series] Any object which can be converted to a list of data points. (Ex: pandas.Series, tuple, list) required accuracy_decimals int Positive integer, specifying number of decimal places to be looked into until we consider two numbers as equal. Ex: with accuracy_decimals=2, 3.456 and 3.457 are considered equal, but 3.456 and 3.466 are considered unequal. 2 Returns: Type Description int 1 if val1_hist(OHLC) cuts val2_hist upwards -1 if val1_hist cuts val2_hist downwards 0 if there is no cut between val1_hist and val2_hist Source code in pyalgotrading/broker/utils.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def crossover ( val1_hist : Union [ Tuple , List , pd . Series ], val2_hist : Union [ Tuple , List , pd . Series ], accuracy_decimals : int = 2 ) -> int : \"\"\" Computes crossover of 2 data series - val1_hist and val2_hist. Args: val1_hist: Any object which can be converted to a list of data points. (Ex: pandas.Series, tuple, list) val2_hist: Any object which can be converted to a list of data points. (Ex: pandas.Series, tuple, list) accuracy_decimals: Positive integer, specifying number of decimal places to be looked into until we consider two numbers as equal. Ex: with accuracy_decimals=2, 3.456 and 3.457 are considered equal, but 3.456 and 3.466 are considered unequal. Returns: - `1` if `val1_hist(OHLC)` cuts `val2_hist` upwards - `-1` if `val1_hist` cuts `val2_hist` downwards - `0` if there is no cut between `val1_hist` and `val2_hist` \"\"\" # This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. pass","title":"crossover()"},{"location":"package_pyalgotrading/#pyalgotrading.constants","text":"A collection of classes of type Enumeration use while programming a new strategy","title":"constants"},{"location":"package_pyalgotrading/#pyalgotrading.constants.AlgoBullsEngineVersion","text":"A class of Versioning Constants","title":"AlgoBullsEngineVersion"},{"location":"package_pyalgotrading/#pyalgotrading.constants.AlgoBullsJobStatus","text":"A class of job status Constants","title":"AlgoBullsJobStatus"},{"location":"package_pyalgotrading/#pyalgotrading.constants.AlgoBullsJobSubmissionResponse","text":"A class of responses when querying the job status","title":"AlgoBullsJobSubmissionResponse"},{"location":"package_pyalgotrading/#pyalgotrading.constants.AlgoBullsSupportedBrokers","text":"A class of supported brokers","title":"AlgoBullsSupportedBrokers"},{"location":"package_pyalgotrading/#pyalgotrading.constants.BrokerOrderCodeConstants","text":"A class of Order Code Constants","title":"BrokerOrderCodeConstants"},{"location":"package_pyalgotrading/#pyalgotrading.constants.BrokerOrderTransactionTypeConstants","text":"A class of Order Transaction Type Constants","title":"BrokerOrderTransactionTypeConstants"},{"location":"package_pyalgotrading/#pyalgotrading.constants.BrokerOrderTypeConstants","text":"A class of Order Type Constants","title":"BrokerOrderTypeConstants"},{"location":"package_pyalgotrading/#pyalgotrading.constants.BrokerOrderVarietyConstants","text":"A class of Order Variety Constants","title":"BrokerOrderVarietyConstants"},{"location":"package_pyalgotrading/#pyalgotrading.constants.CandleInterval","text":"A class of Candle Intervals with their Alternate names","title":"CandleInterval"},{"location":"package_pyalgotrading/#pyalgotrading.constants.PlotType","text":"A class of Plot Types","title":"PlotType"},{"location":"package_pyalgotrading/#pyalgotrading.constants.StrategyMode","text":"A class of Strategy Modes","title":"StrategyMode"},{"location":"package_pyalgotrading/#pyalgotrading.constants.StrategyType","text":"A class of Strategy Type","title":"StrategyType"},{"location":"package_pyalgotrading/#pyalgotrading.constants.TradingReportType","text":"A class of Trading Report Types","title":"TradingReportType"},{"location":"package_pyalgotrading/#pyalgotrading.constants.TradingType","text":"A class of Trading Types","title":"TradingType"},{"location":"package_pyalgotrading/#pyalgotrading.instrument","text":"","title":"instrument"},{"location":"package_pyalgotrading/#pyalgotrading.instrument.instrument","text":"Instrument Class","title":"instrument"},{"location":"package_pyalgotrading/#pyalgotrading.instrument.instrument.Instrument","text":"Instrument Class","title":"Instrument"},{"location":"package_pyalgotrading/#pyalgotrading.instrument.instrument.Instrument.__init__","text":"Init method that is used while creating an object of this class Parameters: Name Type Description Default segment segment required tradingsymbol trading symbol required broker_token alphnumeric token required tick_size tick size required lot_size lot size required expiry expiry date None strike_price strike amount / value None Source code in pyalgotrading/instrument/instrument.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def __init__ ( self , segment , tradingsymbol , broker_token , tick_size , lot_size , expiry = None , strike_price = None ): \"\"\" Init method that is used while creating an object of this class Args: segment: segment tradingsymbol: trading symbol broker_token: alphnumeric token tick_size: tick size lot_size: lot size expiry: expiry date strike_price: strike amount / value \"\"\" self . segment = segment self . exchange = self . segment . exchange self . tradingsymbol = tradingsymbol self . broker_token = broker_token self . tick_size = tick_size self . lot_size = lot_size self . expiry = expiry self . strike_price = strike_price","title":"__init__()"},{"location":"package_pyalgotrading/#pyalgotrading.instrument.instrument.Instrument.is_expired","text":"Returns whether expired or not Returns: Type Description True or False Source code in pyalgotrading/instrument/instrument.py 40 41 42 43 44 45 46 47 48 49 def is_expired ( self ): \"\"\" Returns whether expired or not Returns: True or False \"\"\" if self . expiry : return date . today () > self . expiry else : return False","title":"is_expired()"},{"location":"package_pyalgotrading/#pyalgotrading.instrument.instrument.Instrument.will_expire","text":"Returns expiry details Returns: Type Description a value containing the expiry date Source code in pyalgotrading/instrument/instrument.py 32 33 34 35 36 37 38 def will_expire ( self ): \"\"\" Returns expiry details Returns: a value containing the expiry date \"\"\" return self . expiry","title":"will_expire()"},{"location":"package_pyalgotrading/#pyalgotrading.order","text":"","title":"order"},{"location":"package_pyalgotrading/#pyalgotrading.order.order_base","text":"","title":"order_base"},{"location":"package_pyalgotrading/#pyalgotrading.order.order_base.OrderBase","text":"Base class for Regular Order / Bracket Order","title":"OrderBase"},{"location":"package_pyalgotrading/#pyalgotrading.order.order_base.OrderBase.cancel_order","text":"This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Source code in pyalgotrading/order/order_base.py 32 33 34 35 36 37 38 39 def cancel_order ( self ): \"\"\" This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Returns: \"\"\" # This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. pass","title":"cancel_order()"},{"location":"package_pyalgotrading/#pyalgotrading.order.order_base.OrderBase.exit_position","text":"This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Source code in pyalgotrading/order/order_base.py 23 24 25 26 27 28 29 30 def exit_position ( self ): \"\"\" This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Returns: \"\"\" # This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. pass","title":"exit_position()"},{"location":"package_pyalgotrading/#pyalgotrading.order.order_base.OrderBase.get_order_status","text":"This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Source code in pyalgotrading/order/order_base.py 14 15 16 17 18 19 20 21 def get_order_status ( self ): \"\"\" This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Returns: \"\"\" # This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. pass","title":"get_order_status()"},{"location":"package_pyalgotrading/#pyalgotrading.order.order_base.OrderBase.place_order","text":"This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Source code in pyalgotrading/order/order_base.py 5 6 7 8 9 10 11 12 def place_order ( self ): \"\"\" This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Returns: \"\"\" # This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. pass","title":"place_order()"},{"location":"package_pyalgotrading/#pyalgotrading.order.order_bracket_base","text":"Class for Bracket Order","title":"order_bracket_base"},{"location":"package_pyalgotrading/#pyalgotrading.order.order_bracket_base.BuyOrderBracket","text":"Class for Bracket Order Buy","title":"BuyOrderBracket"},{"location":"package_pyalgotrading/#pyalgotrading.order.order_bracket_base.BuyOrderBracket.__init__","text":"Init method that is used while creating an object of this class Source code in pyalgotrading/order/order_bracket_base.py 53 54 55 56 57 58 def __init__ ( self , instrument , order_code , order_variety , quantity , price = None , trigger_price = None , stoploss_trigger = None , target_trigger = None , trailing_stoploss_trigger = None ): \"\"\" Init method that is used while creating an object of this class \"\"\" super () . __init__ ( instrument = instrument , order_transaction_type = BrokerOrderTransactionTypeConstants . BROKER_ORDER_TRANSACTION_TYPE_BUY , order_code = order_code , order_variety = order_variety , quantity = quantity , price = price , trigger_price = trigger_price , stoploss_trigger = stoploss_trigger , target_trigger = target_trigger , trailing_stoploss_trigger = trailing_stoploss_trigger )","title":"__init__()"},{"location":"package_pyalgotrading/#pyalgotrading.order.order_bracket_base.OrderBracketBase","text":"Class for Bracket Order","title":"OrderBracketBase"},{"location":"package_pyalgotrading/#pyalgotrading.order.order_bracket_base.OrderBracketBase.__init__","text":"Init method that is used while creating an object of this class Parameters: Name Type Description Default instrument instrument key required order_transaction_type order transaction type required order_code bracket order required order_variety market / limit / stoploss market / stoploss limit required quantity order quantity required price amount / value None trigger_price trigger amount / value None stoploss_trigger stoploss trigger amount / value None target_trigger target trigger amount / value None trailing_stoploss_trigger trailing stoploss trigger amount / value None Source code in pyalgotrading/order/order_bracket_base.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def __init__ ( self , instrument , order_transaction_type , order_code , order_variety , quantity , price = None , trigger_price = None , stoploss_trigger = None , target_trigger = None , trailing_stoploss_trigger = None ): \"\"\" Init method that is used while creating an object of this class Args: instrument: instrument key order_transaction_type: order transaction type order_code: bracket order order_variety: market / limit / stoploss market / stoploss limit quantity: order quantity price: amount / value trigger_price: trigger amount / value stoploss_trigger: stoploss trigger amount / value target_trigger: target trigger amount / value trailing_stoploss_trigger: trailing stoploss trigger amount / value \"\"\" self . instrument = instrument self . order_transaction_type = order_transaction_type self . order_type = BrokerOrderTypeConstants . BROKER_ORDER_TYPE_BRACKET self . order_code = order_code self . order_variety = order_variety self . quantity = quantity self . price = price self . trigger_price = trigger_price self . target_trigger = target_trigger self . stoploss_trigger = stoploss_trigger self . trailing_stoploss_trigger = trailing_stoploss_trigger","title":"__init__()"},{"location":"package_pyalgotrading/#pyalgotrading.order.order_bracket_base.OrderBracketBase.is_closed","text":"This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Returns: Type Description True / False Source code in pyalgotrading/order/order_bracket_base.py 39 40 41 42 43 44 45 46 def is_closed ( self ): \"\"\" This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Returns: True / False \"\"\" # This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. pass","title":"is_closed()"},{"location":"package_pyalgotrading/#pyalgotrading.order.order_bracket_base.SellOrderBracket","text":"Class for Bracket Order Sell","title":"SellOrderBracket"},{"location":"package_pyalgotrading/#pyalgotrading.order.order_bracket_base.SellOrderBracket.__init__","text":"Init method that is used while creating an object of this class Source code in pyalgotrading/order/order_bracket_base.py 65 66 67 68 69 70 def __init__ ( self , instrument , order_code , order_variety , quantity , price = None , trigger_price = None , stoploss_trigger = None , target_trigger = None , trailing_stoploss_trigger = None ): \"\"\" Init method that is used while creating an object of this class \"\"\" super () . __init__ ( instrument = instrument , order_transaction_type = BrokerOrderTransactionTypeConstants . BROKER_ORDER_TRANSACTION_TYPE_SELL , order_code = order_code , order_variety = order_variety , quantity = quantity , price = price , trigger_price = trigger_price , stoploss_trigger = stoploss_trigger , target_trigger = target_trigger , trailing_stoploss_trigger = trailing_stoploss_trigger )","title":"__init__()"},{"location":"package_pyalgotrading/#pyalgotrading.order.order_regular_base","text":"Class for Regular Order","title":"order_regular_base"},{"location":"package_pyalgotrading/#pyalgotrading.order.order_regular_base.BuyOrderRegular","text":"Class for Regular Order Buy","title":"BuyOrderRegular"},{"location":"package_pyalgotrading/#pyalgotrading.order.order_regular_base.BuyOrderRegular.__init__","text":"Init method that is used while creating an object of this class Source code in pyalgotrading/order/order_regular_base.py 38 39 40 41 42 43 def __init__ ( self , instrument , order_code , order_variety , quantity , price = None , trigger_price = None ): \"\"\" Init method that is used while creating an object of this class \"\"\" super () . __init__ ( instrument = instrument , order_transaction_type = BrokerOrderTransactionTypeConstants . BROKER_ORDER_TRANSACTION_TYPE_BUY , order_code = order_code , order_variety = order_variety , quantity = quantity , price = price , trigger_price = trigger_price )","title":"__init__()"},{"location":"package_pyalgotrading/#pyalgotrading.order.order_regular_base.OrderRegularBase","text":"Class for Regular Order","title":"OrderRegularBase"},{"location":"package_pyalgotrading/#pyalgotrading.order.order_regular_base.OrderRegularBase.__init__","text":"Init method that is used while creating an object of this class Parameters: Name Type Description Default instrument instrument key required order_transaction_type order transaction type required order_code regular order required order_variety market / limit / stoploss market / stoploss limit required quantity order quantity required price amount / value None trigger_price trigger amount / value None Source code in pyalgotrading/order/order_regular_base.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 def __init__ ( self , instrument , order_transaction_type , order_code , order_variety , quantity , price = None , trigger_price = None ): \"\"\" Init method that is used while creating an object of this class Args: instrument: instrument key order_transaction_type: order transaction type order_code: regular order order_variety: market / limit / stoploss market / stoploss limit quantity: order quantity price: amount / value trigger_price: trigger amount / value \"\"\" self . instrument = instrument self . order_transaction_type = order_transaction_type self . order_type = BrokerOrderTypeConstants . BROKER_ORDER_TYPE_REGULAR self . order_code = order_code self . order_variety = order_variety self . quantity = quantity self . price = price self . trigger_price = trigger_price","title":"__init__()"},{"location":"package_pyalgotrading/#pyalgotrading.order.order_regular_base.SellOrderRegular","text":"Class for Regular Order Buy","title":"SellOrderRegular"},{"location":"package_pyalgotrading/#pyalgotrading.order.order_regular_base.SellOrderRegular.__init__","text":"Init method that is used while creating an object of this class Source code in pyalgotrading/order/order_regular_base.py 50 51 52 53 54 55 def __init__ ( self , instrument , order_code , order_variety , quantity , price = None , trigger_price = None ): \"\"\" Init method that is used while creating an object of this class \"\"\" super () . __init__ ( instrument = instrument , order_transaction_type = BrokerOrderTransactionTypeConstants . BROKER_ORDER_TRANSACTION_TYPE_SELL , order_code = order_code , order_variety = order_variety , quantity = quantity , price = price , trigger_price = trigger_price )","title":"__init__()"},{"location":"package_pyalgotrading/#pyalgotrading.strategy","text":"","title":"strategy"},{"location":"package_pyalgotrading/#pyalgotrading.strategy.strategy_base","text":"","title":"strategy_base"},{"location":"package_pyalgotrading/#pyalgotrading.strategy.strategy_base.StrategyBase","text":"Dummy placeholder class. Here to ensure all required methods are implemented and as per requirements. Once uploaded, this strategy will be replaced with the real base class strategy","title":"StrategyBase"},{"location":"package_pyalgotrading/#pyalgotrading.strategy.strategy_base.StrategyBase.__init__","text":"Init method that is used while creating an object of this class Parameters: Name Type Description Default *args a variable-length argument list () **kwargs a keyworded, variable-length argument list {} Source code in pyalgotrading/strategy/strategy_base.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def __init__ ( self , * args , ** kwargs ): \"\"\" Init method that is used while creating an object of this class Args: *args: a variable-length argument list **kwargs: a keyworded, variable-length argument list \"\"\" # Dummy attributes self . strategy_parameters = defaultdict ( lambda : 'dummy' ) self . broker = broker . broker_connection_base . BrokerConnectionBase () self . utils = broker . utils # Dummy Order Attributes self . BuyOrderRegular = BuyOrderRegular self . SellOrderRegular = SellOrderRegular self . BuyOrderBracket = BuyOrderBracket self . SellOrderBracket = SellOrderBracket # Dummy strategy config attributes self . strategy_mode = StrategyMode . INTRADAY # <Type: Enum of type StrategyMode; This attribute will hold one of the following values - StrategyMode.INTRADAY or StrategyMode.DELIVERY. This value is passed to pyalgotrading.algobulls.connection.backtest/papertest/realtrade methods.> self . number_of_lots = 1 # <Type: This attribute will hold one of the following values - StrategyMode.INTRADAY or StrategyMode.DELIVERY. This value is passed to pyalgotrading.algobulls.connection.backtest/papertest/realtrade methods.>","title":"__init__()"},{"location":"package_pyalgotrading/#pyalgotrading.strategy.strategy_base.StrategyBase.get_historical_data","text":"Fetch the historical data of an instrument This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Parameters: Name Type Description Default instrument instrument key required Returns: Type Description None Source code in pyalgotrading/strategy/strategy_base.py 52 53 54 55 56 57 58 59 60 61 62 63 def get_historical_data ( self , instrument ): \"\"\" Fetch the historical data of an instrument This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. Args: instrument: instrument key Returns: None \"\"\" # This is a dummy function with a sole purpose of mimicing the signature of the actual function on the AlgoBulls platform, as described in the documentation. pass","title":"get_historical_data()"},{"location":"package_pyalgotrading/#pyalgotrading.strategy.strategy_base.StrategyBase.initialize","text":"Initialization task for this strategy. Calling this method should initialise/reset the strategy's internal state variables to original state. Every Strategy should initialize its internal state variables in this task to reset values. Indented to be called by TLS as part of pre market activity & for backtesting mode, at the start of every new backtesting day. Source code in pyalgotrading/strategy/strategy_base.py 74 75 76 77 78 79 80 81 82 83 @abstractmethod def initialize ( self ): \"\"\" Initialization task for this strategy. Calling this method should initialise/reset the strategy's internal state variables to original state. Every Strategy should initialize its internal state variables in this task to reset values. Indented to be called by TLS as part of pre market activity & for backtesting mode, at the start of every new backtesting day. \"\"\" raise NotImplementedError","title":"initialize()"},{"location":"package_pyalgotrading/#pyalgotrading.strategy.strategy_base.StrategyBase.name","text":"Name of the strategy Returns: None Source code in pyalgotrading/strategy/strategy_base.py 42 43 44 45 46 47 48 49 50 @staticmethod @abstractmethod def name (): \"\"\" Name of the strategy Returns: None \"\"\" raise NotImplementedError","title":"name()"},{"location":"package_pyalgotrading/#pyalgotrading.strategy.strategy_base.StrategyBase.strategy_enter_position","text":"Enter position for each instrument Parameters: Name Type Description Default candle the current candle required instrument the instrument key required sideband_info the additional information regarding the instrument action required Returns: Type Description the order, if position is entered Source code in pyalgotrading/strategy/strategy_base.py 97 98 99 100 101 102 103 104 105 106 107 108 109 @abstractmethod def strategy_enter_position ( self , candle , instrument , sideband_info ): \"\"\" Enter position for each instrument Args: candle: the current candle instrument: the instrument key sideband_info: the additional information regarding the instrument action Returns: the order, if position is entered \"\"\" raise NotImplementedError","title":"strategy_enter_position()"},{"location":"package_pyalgotrading/#pyalgotrading.strategy.strategy_base.StrategyBase.strategy_exit_position","text":"Exit position for each instrument Parameters: Name Type Description Default candle the current candle required instrument the instrument key required sideband_info the additional information regarding the instrument action required Returns: Type Description True if order is exited else False Source code in pyalgotrading/strategy/strategy_base.py 124 125 126 127 128 129 130 131 132 133 134 135 136 @abstractmethod def strategy_exit_position ( self , candle , instrument , sideband_info ): \"\"\" Exit position for each instrument Args: candle: the current candle instrument: the instrument key sideband_info: the additional information regarding the instrument action Returns: True if order is exited else False \"\"\" raise NotImplementedError","title":"strategy_exit_position()"},{"location":"package_pyalgotrading/#pyalgotrading.strategy.strategy_base.StrategyBase.strategy_select_instruments_for_entry","text":"Select instruments for entry here Parameters: Name Type Description Default candle the current candle required instruments_bucket the list of instruments to be selected from required Returns: Type Description selected instruments and sideband (additional) information for each Source code in pyalgotrading/strategy/strategy_base.py 85 86 87 88 89 90 91 92 93 94 95 def strategy_select_instruments_for_entry ( self , candle , instruments_bucket ): \"\"\" Select instruments for entry here Args: candle: the current candle instruments_bucket: the list of instruments to be selected from Returns: selected instruments and sideband (additional) information for each \"\"\" raise NotImplementedError","title":"strategy_select_instruments_for_entry()"},{"location":"package_pyalgotrading/#pyalgotrading.strategy.strategy_base.StrategyBase.strategy_select_instruments_for_exit","text":"Select instruments for exit here Parameters: Name Type Description Default candle the current candle required instruments_bucket the list of instruments to be selected from required Returns: Type Description selected instruments and sideband (additional) information for each Source code in pyalgotrading/strategy/strategy_base.py 111 112 113 114 115 116 117 118 119 120 121 122 @abstractmethod def strategy_select_instruments_for_exit ( self , candle , instruments_bucket ): \"\"\" Select instruments for exit here Args: candle: the current candle instruments_bucket: the list of instruments to be selected from Returns: selected instruments and sideband (additional) information for each \"\"\" raise NotImplementedError","title":"strategy_select_instruments_for_exit()"},{"location":"package_pyalgotrading/#pyalgotrading.strategy.strategy_base.StrategyBase.versions_supported","text":"Version of the AlgoBulls platform that this Strategy will run on/tested on :return: Should return a single version or list of versions of ABC on which the current strategy has been tested to run successfully Source code in pyalgotrading/strategy/strategy_base.py 65 66 67 68 69 70 71 72 @staticmethod @abstractmethod def versions_supported (): \"\"\" Version of the AlgoBulls platform that this Strategy will run on/tested on :return: Should return a single version or list of versions of ABC on which the current strategy has been tested to run successfully \"\"\" raise NotImplementedError","title":"versions_supported()"},{"location":"package_pyalgotrading/#pyalgotrading.strategy.validate_strategy","text":"A module in construction. Create class which validates the strategy - 1. Ensures all methods are implemented and all looks good 2. Basic sanity checks Add additional information - 1. Add a versioning information in the class automatically","title":"validate_strategy"},{"location":"package_pyalgotrading/#pyalgotrading.utils","text":"","title":"utils"},{"location":"package_pyalgotrading/#pyalgotrading.utils.candlesticks","text":"Handy functions for computing various candlesticks patterns from OHLC data","title":"candlesticks"},{"location":"package_pyalgotrading/#pyalgotrading.utils.candlesticks.heikinashi","text":"","title":"heikinashi"},{"location":"package_pyalgotrading/#pyalgotrading.utils.candlesticks.heikinashi.HeikinAshi","text":"Computes HeikinAshi Candlesticks Pattern data from Japanese candlesticks pattern data. Parameters: Name Type Description Default japanese_data DataFrame Pandas DataFrame holding Japanese Candlesticks Pattern Data required ohlc tuple Column names corresponding to 'timestamp', 'open', 'high', 'low' and 'close' data respectively ('timestamp', 'open', 'high', 'low', 'close') Returns: Type Description HeikinAshi Candlesticks Pattern data Source code in pyalgotrading/utils/candlesticks/heikinashi.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def HeikinAshi ( japanese_data : pd . DataFrame , ohlc : tuple = ( 'timestamp' , 'open' , 'high' , 'low' , 'close' )): \"\"\" Computes HeikinAshi Candlesticks Pattern data from Japanese candlesticks pattern data. Args: japanese_data: Pandas DataFrame holding Japanese Candlesticks Pattern Data ohlc: Column names corresponding to 'timestamp', 'open', 'high', 'low' and 'close' data respectively Returns: HeikinAshi Candlesticks Pattern data \"\"\" if not len ( ohlc ) >= 5 : print ( \"Argument 'ohlc' should be a tuple of 5 values corresponding to the column names in 'japanese_data' pandas DataFrame, for 'timestamp', 'open', 'high', 'low' and 'close' data respectively.\" ) ha_open = 'ha_' + ohlc [ 0 ] ha_high = 'ha_' + ohlc [ 1 ] ha_low = 'ha_' + ohlc [ 2 ] ha_close = 'ha_' + ohlc [ 3 ] japanese_data = japanese_data . copy () # make sure we don't modify the original DataFrame japanese_data [ ha_close ] = ( japanese_data [ ohlc [ 1 ]] + japanese_data [ ohlc [ 2 ]] + japanese_data [ ohlc [ 3 ]] + japanese_data [ ohlc [ 4 ]]) / 4 japanese_data [ ha_open ] = 0.0 for i in range ( 0 , len ( japanese_data )): if i == 0 : japanese_data [ ha_open ] . iat [ i ] = ( japanese_data [ ohlc [ 1 ]] . iat [ i ] + japanese_data [ ohlc [ 4 ]] . iat [ i ]) / 2 else : japanese_data [ ha_open ] . iat [ i ] = ( japanese_data [ ha_open ] . iat [ i - 1 ] + japanese_data [ ha_close ] . iat [ i - 1 ]) / 2 japanese_data [ ha_high ] = japanese_data [[ ha_open , ha_close , ohlc [ 2 ]]] . max ( axis = 1 ) japanese_data [ ha_low ] = japanese_data [[ ha_open , ha_close , ohlc [ 3 ]]] . min ( axis = 1 ) # Create separate DataFrame with the required columns only heikinashi_data = pd . DataFrame () heikinashi_data [ 'timestamp' ] = japanese_data [ 'timestamp' ] heikinashi_data [ 'open' ] = japanese_data [ ha_open ] heikinashi_data [ 'high' ] = japanese_data [ ha_high ] heikinashi_data [ 'low' ] = japanese_data [ ha_low ] heikinashi_data [ 'close' ] = japanese_data [ ha_close ] return heikinashi_data","title":"HeikinAshi()"},{"location":"package_pyalgotrading/#pyalgotrading.utils.candlesticks.linebreak","text":"","title":"linebreak"},{"location":"package_pyalgotrading/#pyalgotrading.utils.candlesticks.linebreak.Linebreak","text":"Parameters: Name Type Description Default japanese_candles required Source code in pyalgotrading/utils/candlesticks/linebreak.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def Linebreak ( japanese_candles ): \"\"\" Args: japanese_candles: Returns: \"\"\" linebreak_candles = [{ 'close' : candle [ 'close' ], 'open' : candle [ 'open' ], 'timestamp' : candle [ 'timestamp' ]} for _ , candle in japanese_candles . iloc [: 3 ] . iterrows ()] for _ , candle in japanese_candles . iloc [ 3 :] . iterrows (): all_greater = all ( candle [ 'close' ] > _ for _ in [ max ( _linebreakcandle [ 'open' ], _linebreakcandle [ 'close' ]) for _linebreakcandle in linebreak_candles [ - 3 :]]) all_lesser = all ( candle [ 'close' ] < _ for _ in [ min ( _linebreakcandle [ 'open' ], _linebreakcandle [ 'close' ]) for _linebreakcandle in linebreak_candles [ - 3 :]]) prev_linebreak_candle = linebreak_candles [ - 1 ] if all_greater : new_linebreak_candle = { 'open' : max ( prev_linebreak_candle [ 'open' ], prev_linebreak_candle [ 'close' ]), 'close' : candle [ 'close' ], 'timestamp' : candle [ 'timestamp' ]} linebreak_candles . append ( new_linebreak_candle ) elif all_lesser : new_linebreak_candle = { 'open' : min ( prev_linebreak_candle [ 'open' ], prev_linebreak_candle [ 'close' ]), 'close' : candle [ 'close' ], 'timestamp' : candle [ 'timestamp' ]} linebreak_candles . append ( new_linebreak_candle ) return pd . DataFrame ( linebreak_candles )","title":"Linebreak()"},{"location":"package_pyalgotrading/#pyalgotrading.utils.candlesticks.renko","text":"","title":"renko"},{"location":"package_pyalgotrading/#pyalgotrading.utils.candlesticks.renko.Renko","text":"Parameters: Name Type Description Default japanese_candles required brick_count 2 initial_open None initial_close None Source code in pyalgotrading/utils/candlesticks/renko.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def Renko ( japanese_candles , brick_count = 2 , initial_open = None , initial_close = None ): \"\"\" Args: japanese_candles: brick_count: initial_open: initial_close: Returns: \"\"\" if not initial_close : initial_open = japanese_candles . iloc [ 0 ][ 'open' ] initial_close = japanese_candles . iloc [ 0 ][ 'close' ] else : initial_open = japanese_candles . iloc [ 0 ][ 'open' ] + ( brick_count - (( japanese_candles . iloc [ 0 ][ 'open' ] - initial_open ) % brick_count )) initial_close = japanese_candles . iloc [ 0 ][ 'close' ] + ( brick_count - (( japanese_candles . iloc [ 0 ][ 'close' ] - initial_close ) % brick_count )) renko_candles = [{ 'timestamp' : japanese_candles . iloc [ 0 ][ 'timestamp' ], 'open' : initial_open , 'close' : initial_close }] prev_renko_candle = renko_candles [ - 1 ] for _ , candle in japanese_candles . iloc [ 1 :] . iterrows (): max_open_close = max ( prev_renko_candle [ 'open' ], prev_renko_candle [ 'close' ]) min_open_close = min ( prev_renko_candle [ 'open' ], prev_renko_candle [ 'close' ]) if candle [ 'close' ] > max_open_close : number_of_renko_candles = math . floor (( candle [ 'close' ] - max_open_close ) / brick_count ) for i in range ( number_of_renko_candles ): renko_candles . append ({ 'timestamp' : candle [ 'timestamp' ], 'open' : max_open_close , 'close' : max_open_close + brick_count }) prev_renko_candle = renko_candles [ - 1 ] max_open_close = max ( prev_renko_candle [ 'open' ], prev_renko_candle [ 'close' ]) elif candle [ 'close' ] < min_open_close : number_of_renko_candles = math . floor (( min_open_close - candle [ 'close' ]) / brick_count ) for i in range ( number_of_renko_candles ): renko_candles . append ({ 'timestamp' : candle [ 'timestamp' ], 'open' : min_open_close , 'close' : min_open_close - brick_count }) prev_renko_candle = renko_candles [ - 1 ] min_open_close = min ( prev_renko_candle [ 'open' ], prev_renko_candle [ 'close' ]) return pd . DataFrame ( renko_candles )","title":"Renko()"},{"location":"package_pyalgotrading/#pyalgotrading.utils.func","text":"A module for plotting candlesticks","title":"func"},{"location":"package_pyalgotrading/#pyalgotrading.utils.func.import_with_install","text":"Helps import 'package' even if its not installed. If package is installed, it will be imported and returned. If its not installed, it will be installed using 'pip' and a re-import will be attempted, which should succeed if the package was imported correctly. Parameters: Name Type Description Default package_import_name name of package to be installed using pip, str required package_install_name name of package to be imported. Default is None, which means package can be imported with the same name as used for installation. If not, this parameter can be used to specify a different import name. None package_version version of package to be installed, str, Example: '1.0.0' or '==1.0.0' '' Returns: Type Description The imported package Source code in pyalgotrading/utils/func.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def import_with_install ( package_import_name , package_install_name = None , package_version = '' ): \"\"\" Helps import 'package' even if its not installed. If package is installed, it will be imported and returned. If its not installed, it will be installed using 'pip' and a re-import will be attempted, which should succeed if the package was imported correctly. Args: package_import_name: name of package to be installed using pip, str package_install_name: name of package to be imported. Default is None, which means package can be imported with the same name as used for installation. If not, this parameter can be used to specify a different import name. package_version: version of package to be installed, str, Example: '1.0.0' or '==1.0.0' Returns: The imported package \"\"\" package_install_name = package_install_name if package_install_name is not None else package_import_name package_version = f '== { package_version } ' if (( package_version != '' ) and ( '==' not in package_version )) else package_version try : return __import__ ( package_import_name ) except ImportError : print ( f \"Installing package { package_import_name } via pip...\" ) import subprocess import sys subprocess . check_call ([ sys . executable , '-m' , 'pip' , 'install' , package_install_name , package_version ]) return __import__ ( package_import_name )","title":"import_with_install()"},{"location":"package_pyalgotrading/#pyalgotrading.utils.func.plot_candlestick_chart","text":"Function to create charts for various candlesticks pattern data - - Japanese - Heikin-Ashi - Linebreak - Renko - Japanese for Quandl data Support for displaying indicator data (on top of candlesticks pattern data or separately). Parameters: Name Type Description Default data DataFrame Pandas DataFrame with columns timestamp , open , 'high , 'low , close required plot_type PlotType Enum of type PlotType required caption str Caption for the chart '' hide_missing_dates bool If True, missing dates in the data (say due to no data over weekend) will be hidden and a continuous plot will be shown. If False, gaps would be shown for missing dates. However, the date formatting on the x-axis is better here, so prefer this when there are no date gaps. False show bool If True, figure will be shown. Useful for displaying figures inline while using Jupyter Notebooks True indicators tuple Indicator data to be displayed () plot_indicators_separately bool If True, indicator data would be plotted in a different subplot. Use this when indicator data range coincides with the historical data range. If False, it will be plotted in the same subplot as the historical data. Use this when indicator data range does not coincide with the historical data range False plot_height int Plot height in pixels 500 plot_width int Plot width in pixels 1000 Source code in pyalgotrading/utils/func.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 def plot_candlestick_chart ( data : pd . DataFrame , plot_type : PlotType , caption : str = '' , hide_missing_dates : bool = False , show : bool = True , indicators : tuple = (), plot_indicators_separately : bool = False , plot_height : int = 500 , plot_width : int = 1000 ): \"\"\" Function to create charts for various candlesticks pattern data - - Japanese - Heikin-Ashi - Linebreak - Renko - Japanese for Quandl data Support for displaying indicator data (on top of candlesticks pattern data or separately). Args: data: Pandas DataFrame with columns `timestamp`, `open`, 'high`, 'low`, `close` plot_type: Enum of type PlotType caption: Caption for the chart hide_missing_dates: If True, missing dates in the `data` (say due to no data over weekend) will be hidden and a continuous plot will be shown. If False, gaps would be shown for missing dates. However, the date formatting on the x-axis is better here, so prefer this when there are no date gaps. show: If True, figure will be shown. Useful for displaying figures inline while using Jupyter Notebooks indicators: Indicator data to be displayed plot_indicators_separately: If True, indicator data would be plotted in a different subplot. Use this when indicator data range coincides with the historical data range. If False, it will be plotted in the same subplot as the historical data. Use this when indicator data range does not coincide with the historical data range plot_height: Plot height in pixels plot_width: Plot width in pixels \"\"\" import_with_install ( package_import_name = 'plotly' , package_install_name = 'plotly' , package_version = '4.7.1' ) from plotly.subplots import make_subplots from plotly import graph_objects as go # Sanity checks if not isinstance ( plot_type , PlotType ): print ( f 'Error: plot_type should be an instance of { PlotType . __class__ } ' ) return # Plot if plot_type is PlotType . QUANDL_JAPANESE : data [ 'timestamp' ] = data . index if hide_missing_dates : # Plotly has a limitation where if the timestamp are DateTime.DateTime objects which are not continuous, # it will plot the missing dates as empty space, which makes the curve look unnatural. The below code gives # custom timestamp formatting, which will be the x-axis ticks format_timestamp = lambda x : x . strftime ( \" %d /%m %H:%M\" ) timestamps = data [ 'timestamp' ] . apply ( format_timestamp ) else : timestamps = data [ 'timestamp' ] candlesticks_data_subplot_row_index = 1 candlesticks_data_subplot_col_index = 1 if indicators and ( plot_indicators_separately is True ): fig = make_subplots ( rows = 3 , cols = 1 , vertical_spacing = 0.05 , shared_xaxes = True , specs = [[{ \"rowspan\" : 2 }], [{}], [{}]]) indicator_subplot_row_index = 3 indicator_subplot_col_index = 1 else : fig = make_subplots ( rows = 1 , cols = 1 , vertical_spacing = 0.05 , shared_xaxes = True ) indicator_subplot_row_index = 1 indicator_subplot_col_index = 1 if plot_type in [ PlotType . JAPANESE , PlotType . HEIKINASHI ]: fig . append_trace ( go . Candlestick ( x = timestamps , open = data [ 'open' ], high = data [ 'high' ], low = data [ 'low' ], close = data [ 'close' ], name = 'Historical Data' ), row = candlesticks_data_subplot_row_index , col = candlesticks_data_subplot_col_index ) elif plot_type == PlotType . LINEBREAK : fig = go . Figure ( data = [ go . Candlestick ( x = timestamps , open = data [ 'open' ], high = data [[ \"open\" , \"close\" ]] . max ( axis = 1 ), low = data [[ \"open\" , \"close\" ]] . min ( axis = 1 ), close = data [ 'close' ], name = 'Historical Data' )]) elif plot_type == PlotType . RENKO : fig = go . Figure ( data = [ go . Candlestick ( x = timestamps , open = data [ 'open' ], high = data [[ \"open\" , \"close\" ]] . max ( axis = 1 ), low = data [[ \"open\" , \"close\" ]] . min ( axis = 1 ), close = data [ 'close' ], name = 'Historical Data' )]) elif plot_type == PlotType . QUANDL_JAPANESE : fig = go . Figure ( data = [ go . Candlestick ( x = timestamps , open = data [ 'Open' ], high = data [ 'High' ], low = data [ 'Low' ], close = data [ 'Close' ], name = 'Historical Data' )]) else : print ( f 'Error: plot_type ( { plot_type } ) is not implemented yet' ) return for indicator in indicators : indicator_name = indicator [ 'name' ] indicator_data = indicator [ 'data' ] extra = indicator [ 'extra' ] if 'extra' in indicator else {} fig . add_trace ( go . Scatter ( x = timestamps , y = indicator_data , name = indicator_name , ** extra ), row = indicator_subplot_row_index , col = indicator_subplot_col_index ) # Plot customization if hide_missing_dates : # Plotly has a limitation where if the timestamp are DateTime.DateTime objects which are not continuous, # it will plot the missing dates as empty space, which makes the curve look unnatural. Hence, the below fix fig . layout . xaxis . type = 'category' fig . update ( layout_xaxis_rangeslider_visible = False ) fig . update_layout ( title = { 'text' : caption , 'y' : 0.9 , 'x' : 0.5 , 'xanchor' : 'center' , 'yanchor' : 'bottom' }, height = plot_height , width = plot_width ) # Show the plot if show : fig . show () global counter fig . write_image ( f 'fig_ { counter } .pdf' ) counter += 1","title":"plot_candlestick_chart()"},{"location":"tutorial/","text":"Landing Page \u00b6 The landing page is the default page that comes up for any member that logs in to AlgoBulls. Operations \u00b6 Click on your account name to see a drop-down of various options. Build your Strategy \u00b6 Your Wallet \u00b6 Notifications \u00b6 Press the bell icon to see the most recent important activities/events in your account as they happen. A sample of how that looks is shown below. Note: You can also log-out by clicking on your account name and choosing the Log Out option.","title":"Landing Page"},{"location":"tutorial/#landing-page","text":"The landing page is the default page that comes up for any member that logs in to AlgoBulls.","title":"Landing Page"},{"location":"tutorial/#operations","text":"Click on your account name to see a drop-down of various options.","title":"Operations"},{"location":"tutorial/#build-your-strategy","text":"","title":"Build your Strategy"},{"location":"tutorial/#your-wallet","text":"","title":"Your Wallet"},{"location":"tutorial/#notifications","text":"Press the bell icon to see the most recent important activities/events in your account as they happen. A sample of how that looks is shown below. Note: You can also log-out by clicking on your account name and choosing the Log Out option.","title":"Notifications"}]}